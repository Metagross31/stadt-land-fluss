{"version":3,"sources":["utils/game.utils.ts","components/ScoringOptionsList/ScoringOptionsList.tsx","components/JoinGameLink/JoinGameLink.module.css","models/pub-nub-data.model.ts","components/AdminPanel/AdminPanel.tsx","components/LetterAnimation/LetterAnimation.tsx","components/GameRoundChip/GameRoundChip.tsx","components/PhaseEvaluateRound/PhaseEvaluateRound.tsx","components/RoundCountdown/RoundCountdown.tsx","components/PhaseFillOutTextfields/PhaseFillOutTextfields.tsx","components/JoinGameLink/JoinGameLink.tsx","components/PlayerList/PlayerList.tsx","components/PhaseWaitingToStart/PhaseWaitingToStart.tsx","components/PubNubEventHandler/PubNubEventHandler.tsx","config/pubnub.config.ts","utils/data-restoration.utils.ts","containers/PlayGame/PlayGame.tsx"],"names":["getRandomnLetters","numberOfLetters","possibleLetters","length","Error","randomnLetters","lettersToRandomnlySelectFrom","i","randomnLetter","randomnItem","push","filter","letter","getPlayersInAlphabeticalOrder","players","Array","from","map","data","sort","a","b","name","toLowerCase","getEmptyRoundInputs","numberOfInputs","createAndFillArray","points","STANDARD_POINTS","star","text","valid","markEmptyPlayerInputsAsInvalid","playerInputs","input","trim","createGameRoundEvaluation","categories","gameRoundEvaluation","Map","forEach","evaluatedPlayer","evaluationsForAllCategories","_","evaluationForOneCategory","evaluatingPlayer","set","id","calculatePointsForRound","scoringOptions","round","checkForDuplicates","onlyPlayerWithValidAnswer","playerId","keys","next","value","playerInputsOfPlayer1","get","categoryIndex","calculatePointsForCategory","isOnlyPlayerWithValidAnswer","ONLY_ANSWER_POINTS","isDuplicateOfOtherPlayersInput","SAME_WORD_POINTS","otherPlayersIds","isOnlyPlayer","playerInputText","replace","some","otherPlayersInput","getMinNumberOfInvalids","numberOfPlayers","getNumberOfInvalids","evaluations","count","markedAsValid","getRejectingPlayers","rejectingPlayers","playerInfo","applyValidFlagAndStarFlagToPoints","creativeAnswersExtraPoints","EXTRA_POINTS","calculateGameResults","allPlayers","gameRounds","gameResults","pointsPerPlayer","playerName","reduce","total","Object","createHallOfFameData","gameConfig","hallOfFameData","playerInput","category","ScoringOptionsList","props","rules","Fragment","className","GAME_OPTION_LABEL","module","exports","PubNubMessageType","useStyles","makeStyles","adminPanel","position","top","right","menuButton","background","dialogContent","maxWidth","dialogContentText","color","KickUserDialog","classes","onClose","open","Dialog","DialogContent","root","playerToBeKicked","DialogContentText","DialogActions","Button","type","onClick","AdminPanel","useState","anchorEl","setAnchorEl","openDialog","setOpenDialog","setPlayerToBeKicked","otherPlayers","isAdmin","sortedPlayers","IconButton","title","aria-label","aria-controls","aria-haspopup","event","currentTarget","Menu","keepMounted","Boolean","playerIndex","MenuItem","key","selectedPlayer","ListItemIcon","ListItemText","primary","kickPlayer","Particle","x","y","radius","ctx","save","translate","this","fillStyle","fillRect","restore","ParticleAlphabet","letters","callbackWhenAnimationDone","canvas","currentPos","width","height","particlePositions","particles","tmpCanvas","tmpCtx","time","counter","myInterval","activeTheme","animate","requestAnimationFrame","animationBackgroundColor","animateParticles","document","querySelector","getContext","mainElement","AppThemes","find","theme","classList","contains","offsetWidth","offsetHeight","createElement","setInterval","changeLetter","getPixels","clearInterval","LETTER_ANIMATION_REDRAW_SPEED","makeParticles","num","Math","random","keyword","window","innerWidth","innerHeight","font","fillText","measureText","idata","getImageData","buffer32","Uint32Array","buffer","p","pPos","indexOf","draw","LetterAnimation","lettersToUse","STANDARD_ALPHABET","letterToUnveil","lettersForAnimation","LETTER_ANIMATION_LETTER_COUNT","useEffect","init","centerContent","display","justifyContent","chip","marginTop","borderRadius","fontSize","boxShadow","GameRoundChip","currentLetter","currentRound","numberOfRounds","Chip","icon","label","StyledBadge","withStyles","createStyles","badge","border","palette","paper","padding","Badge","PhaseEvaluateRound","playersThatFinishedEvaluation","has","hasFinishedEvaluation","setHasFinishedEvaluation","isSnackbarOpen","setIsSnackbarOpen","snackBarMessage","setSnackBarMessage","currentRoundEvaluation","finishedRound","notFinishedPlayers","player","showSnackBar","message","createEvaluationButton","indexInSortedPlayers","evaluationForCategory","isInputAcceptedByUser","tooltipText","join","hasPlayerTypedText","evaluationButtonForTypedText","Tooltip","evaluatedPlayerId","currentEvaluation","updateEvaluationOfPlayerInput","handleEvaluationButtonClick","badgeContent","autoRejectIconForMissingText","createSearchLink","searchLink","encodeURIComponent","href","target","rel","placement","createMarkAsCreativeAnswerToggle","size","isMarkedAsCreative","updateIsPlayerInputVeryCreativeStatus","markedAsCreative","handleMarkAsCreativeAnswerToggleClick","createPointsChip","evaluatedPlayerInput","noValidate","autoComplete","SectionHeader","showDivider","isInputValid","inputCssClass","TextField","variant","fullWidth","InputProps","spellCheck","startAdornment","InputAdornment","endAdornment","playerEvaluationElements","sendEvaluationFinishedMessage","Snackbar","anchorOrigin","vertical","horizontal","autoHideDuration","countdown","bottom","backgroundColor","main","contrastText","React","memo","date","Date","now","duration","renderer","zeroPad","minutes","seconds","onComplete","PhaseFillOutTextfields","gameRoundInputs","endRoundButton","finishRoundOnUserAction","countdownElement","durationOfCountdown","finishRoundOnCountdownComplete","index","onChange","newGameRoundInputs","updateCurrentRoundInputs","handleInputChange","useCountdown","PubNubCurrentRoundInputsMessage","payload","currentRoundInputs","PubNubEvaluationOfPlayerInputMessage","evaluationOfPlayerInput","PubNubIsPlayerInputVeryCreativeMessage","isPlayerInputVeryCreative","PubNubKickPlayerMessage","PubNubDataForCurrentGameMessage","dataForCurrentGame","JoinGameLink","setOpen","url","location","joinGameLink","slice","gameId","styles","link_label","OutlinedInput","disabled","copyToClipboard","flexWrap","spacing","margin","PlayerList","PhaseWaitingToStart","waitForGameStartElement","Divider","startIcon","MIN_NUMBER_OF_PLAYERS","sendMessage","startGame","pubNubClient","usePubNub","setUserState","newUserState","setState","channels","gameChannel","state","getHereNowData","hereNow","includeUUIDs","includeState","response","console","log","isRejoiningGame","totalOccupancy","navigateToDashboard","dataForGameChannel","pubNubUserStates","occupants","occupant","userState","addPlayers","pubNubListeners","messageEvent","processPubNubMessage","presence","presenceEvent","action","status","statusEvent","history","channel","messages","setTimeout","addListener","subscribe","withPresence","removeListener","unsubscribeAll","PUBNUB_KEYS","require","PUBNUB_CONFIG","publishKey","subscribeKey","uuid","undefined","ssl","shouldUserRespondToRequestGameDataMessage","user","requestingPlayerId","requestingPlayerInfo","playersWithoutRequestingPlayer","cloneDeep","delete","compressGameRoundEvaluation","evaluationsAsArrays","item","booleanArray","compressedGameRoundEvaluation","decompressGameRoundEvaluation","compressedData","evaluatedPlayerIndex","playerData","playerInputEvaluation","evaluatingPlayerIndex","compressMarkedAsCreativeFlags","markedAsCreativeArrays","restoreGameRoundsOfRunningGameFromLocalStorage","numberOfRoundsToRestore","getRunningGameRoundFromLocalStorage","setPointsAndValidity","minNumberOfInvalids","applyMarkedAsCreativeFlags","markedAsCreativeAnswer","PlayGame","currentPhase","GamePhase","waitingToStart","showLetterAnimation","showLoadingScreen","publish","storeInHistory","ttl","createCurrentPhaseElement","fillOutTextfields","evaluateRound","removeAllDataOfRunningGameFromLocalStorage","onResetAppState","newPlayers","newPlayer","setRunningGameConfigInLocalStorage","roundFinished","stopRoundAndSendInputs","addPlayerInputForFinishedRound","publisher","processEvaluationOfPlayerInput","processIsPlayerInputVeryCreativeStatus","evaluationFinished","countPlayerAsEvaluationFinished","removePlayerFromGame","requestGameData","sendDataForCurrentGame","sendKickPlayerMessage","restoreDataForCurrentGame","newCurrentRoundInputs","toPubNubMessage","playerInputsForFinishedRound","roundIndex","setRunningGameRoundInLocalStorage","newEvaluation","evaluatingPlayerId","playerInputEvaluations","newStatus","processEvaluationsAndStartNextRoundOrFinishGame","onSetDataOfFinishedGame","compressedMarkedAsCreativeFlags","convertMapToCollection","getRunningGameConfigFromLocalStorage","convertCollectionToMap","Pubnub","letterAnimationElement","client","LoadingScreen","Component","connect","dispatch","setDataOfFinishedGame","resetAppState"],"mappings":"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","file":"static/js/9.8235a528.chunk.js","sourcesContent":["import { some } from 'lodash';\r\nimport randomnItem from 'random-item';\r\nimport { ONLY_ANSWER_POINTS, SAME_WORD_POINTS, STANDARD_POINTS } from '../constants/game.constant';\r\nimport { Collection } from '../models/collection.interface';\r\nimport { GameConfigScoringOptions, PlayerInput, HallOfFameEntry } from '../models/game.interface';\r\nimport { PlayerInfo } from '../models/player.interface';\r\nimport { EXTRA_POINTS } from './../constants/game.constant';\r\nimport { GameResultForPlayer, GameRound, GameRoundEvaluation, PlayerInputEvaluation, GameConfig } from './../models/game.interface';\r\nimport { createAndFillArray } from './general.utils';\r\n\r\n/**\r\n* Returns an array of unique letters. The number of letters is defined by the parameter numberOfLetters.\r\n* If the second argument is not provided, then the standard alphabet (excluding Q, X and Y) is used.\r\n*/\r\nexport const getRandomnLetters = (numberOfLetters: number, possibleLetters: string[]): string[] => {\r\n    if (numberOfLetters > possibleLetters.length) {\r\n        throw new Error('Cannot create more randomn unique letters than the number of possibleLetters provided!');\r\n    }\r\n    const randomnLetters: string[] = [];\r\n    let lettersToRandomnlySelectFrom = [...possibleLetters];\r\n    for (let i = 0; i < numberOfLetters; i++) {\r\n        const randomnLetter = randomnItem(lettersToRandomnlySelectFrom);\r\n        randomnLetters.push(randomnLetter);\r\n        lettersToRandomnlySelectFrom = lettersToRandomnlySelectFrom.filter(letter => letter !== randomnLetter);\r\n    }\r\n    return randomnLetters;\r\n};\r\n\r\nexport const getPlayersInAlphabeticalOrder = (players: Map<string, PlayerInfo>): PlayerInfo[] => {\r\n    const playerInfoArray = Array.from(players).map(data => data[1]);\r\n    return playerInfoArray.sort((a, b) => {\r\n        if (a.name.toLowerCase() < b.name.toLowerCase()) { return -1; }\r\n        if (a.name.toLowerCase() > b.name.toLowerCase()) { return 1; }\r\n        return 0;\r\n    });\r\n};\r\n\r\n/**\r\n * Returns an array of PlayerInput objects with empty strings and default settings (isMarkedCreative=false, valid=true, standard points).\r\n */\r\nexport const getEmptyRoundInputs = (numberOfInputs: number): PlayerInput[] => {\r\n    return createAndFillArray<PlayerInput>(numberOfInputs, { points: STANDARD_POINTS, star: false, text: '', valid: true });\r\n};\r\n\r\n/**\r\n* Checks each PlayerInput object whether it contains text.\r\n* If text string is empty, valid is set to false, otherwise to true.\r\n* The text is also trimmed in order to support correct scoring (finding duplicates).\r\n*/\r\nexport const markEmptyPlayerInputsAsInvalid = (playerInputs: PlayerInput[]): PlayerInput[] => {\r\n    return playerInputs.map(input => ({ ...input, text: input.text.trim(), valid: !!input.text }));\r\n};\r\n\r\nexport const createGameRoundEvaluation = (players: Map<string, PlayerInfo>, categories: string[]): GameRoundEvaluation => {\r\n    const gameRoundEvaluation = new Map<string, PlayerInputEvaluation[]>();\r\n    players.forEach(evaluatedPlayer => {\r\n        const evaluationsForAllCategories: PlayerInputEvaluation[] = [];\r\n        categories.forEach(_ => {\r\n            const evaluationForOneCategory: PlayerInputEvaluation = new Map<string, boolean>();\r\n            players.forEach(evaluatingPlayer => {\r\n                // The default evaluation for each input is valid (= true).\r\n                evaluationForOneCategory.set(evaluatingPlayer.id, true);\r\n            });\r\n            evaluationsForAllCategories.push(evaluationForOneCategory);\r\n        });\r\n        gameRoundEvaluation.set(evaluatedPlayer.id, evaluationsForAllCategories);\r\n    });\r\n    return gameRoundEvaluation;\r\n};\r\n\r\n/**\r\n * Calculates the points for the round's inputs according to the active scoring options.\r\n */\r\nexport const calculatePointsForRound = (scoringOptions: GameConfigScoringOptions, round: GameRound) => {\r\n    if (!scoringOptions.checkForDuplicates && !scoringOptions.onlyPlayerWithValidAnswer) { return; }\r\n    const playerId = round.keys().next().value;\r\n    const playerInputsOfPlayer1 = round.get(playerId) as PlayerInput[];\r\n    // Loop through all categories.\r\n    for (let categoryIndex = 0; categoryIndex < playerInputsOfPlayer1.length; categoryIndex++) {\r\n        calculatePointsForCategory(scoringOptions, round, categoryIndex);\r\n    }\r\n};\r\n\r\n/**\r\n * Calculates the points for the round's inputs for one category according to the active scoring options.\r\n */\r\nexport const calculatePointsForCategory = (scoringOptions: GameConfigScoringOptions, round: GameRound, categoryIndex: number) => {\r\n    if (!scoringOptions.checkForDuplicates && !scoringOptions.onlyPlayerWithValidAnswer) { return; }\r\n    Array.from(round.keys()).forEach(playerId => {\r\n        const playerInputs = round.get(playerId) as PlayerInput[];\r\n        // Only check valid inputs.\r\n        if (playerInputs[categoryIndex].valid) {\r\n            if (scoringOptions.onlyPlayerWithValidAnswer && isOnlyPlayerWithValidAnswer(playerId, round, categoryIndex)) {\r\n                playerInputs[categoryIndex].points = ONLY_ANSWER_POINTS;\r\n            } else {\r\n                if (scoringOptions.checkForDuplicates && isDuplicateOfOtherPlayersInput(playerId, round, categoryIndex)) {\r\n                    playerInputs[categoryIndex].points = SAME_WORD_POINTS;\r\n                } else {\r\n                    playerInputs[categoryIndex].points = STANDARD_POINTS;\r\n                }\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nexport const isOnlyPlayerWithValidAnswer = (playerId: string, round: GameRound, categoryIndex: number): boolean => {\r\n    const otherPlayersIds = Array.from(round.keys()).filter(id => id !== playerId);\r\n    let isOnlyPlayer = true;\r\n    otherPlayersIds.forEach(id => isOnlyPlayer = isOnlyPlayer && !(round.get(id) as PlayerInput[])[categoryIndex].valid);\r\n    return isOnlyPlayer;\r\n};\r\n\r\n/**\r\n * Returns true if a duplicate (removes all non-alphanumeric characters for comparison) for playerId's input was found.\r\n */\r\nexport const isDuplicateOfOtherPlayersInput = (playerId: string, round: GameRound, categoryIndex: number): boolean => {\r\n    const otherPlayersIds = Array.from(round.keys()).filter(id => id !== playerId);\r\n    const playerInputText = (round.get(playerId) as PlayerInput[])[categoryIndex].text.toLowerCase().replace(/[^0-9a-z]/gi, '');\r\n    return some(otherPlayersIds, id => {\r\n        const otherPlayersInput = (round.get(id) as PlayerInput[])[categoryIndex];\r\n        return otherPlayersInput.valid && playerInputText === otherPlayersInput.text.toLowerCase().replace(/[^0-9a-z]/gi, '');\r\n    });\r\n};\r\n\r\n/**\r\n * Determines the minimum number of players that need to mark a player's input as invalid\r\n * for the input text to be set to invalid and not count as a point for the player.\r\n */\r\nexport const getMinNumberOfInvalids = (numberOfPlayers: number): number => {\r\n    return numberOfPlayers <= 3 ? 1 : 2;\r\n};\r\n\r\n/**\r\n * Returns how many players marked the input as invalid.\r\n */\r\nexport const getNumberOfInvalids = (evaluations: PlayerInputEvaluation): number => {\r\n    let count = 0;\r\n    evaluations.forEach(markedAsValid => count = markedAsValid ? count : count + 1);\r\n    return count;\r\n};\r\n\r\n/**\r\n * Returns the players that marked the input as invalid in alphabetical order. Parameters:\r\n * - evaluations: Evaluations of all players for one player's input for one category.\r\n * - players: All players taking part in the running game of \"Stadt-Land-Fluss\".\r\n */\r\nexport const getRejectingPlayers = (evaluations: PlayerInputEvaluation, players: Map<string, PlayerInfo>): PlayerInfo[] => {\r\n    const rejectingPlayers = new Map<string, PlayerInfo>();\r\n    evaluations.forEach((markedAsValid, playerId) => {\r\n        if (!markedAsValid) {\r\n            const playerInfo = players.get(playerId);\r\n            if (playerInfo) {\r\n                rejectingPlayers.set(playerId, playerInfo);\r\n            }\r\n        }\r\n    });\r\n    return getPlayersInAlphabeticalOrder(rejectingPlayers);\r\n};\r\n\r\n/**\r\n * Adds extra points for \"very creative answers\" if scoring option is active\r\n * and sets invalid answer's points to zero.\r\n */\r\nexport const applyValidFlagAndStarFlagToPoints = (scoringOptions: GameConfigScoringOptions, round: GameRound) => {\r\n    round.forEach(playerInputs => {\r\n        playerInputs.forEach(input => {\r\n            if (!input.valid) {\r\n                input.points = 0;\r\n            } else if (scoringOptions.creativeAnswersExtraPoints && input.star) {\r\n                input.points = input.points + EXTRA_POINTS;\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * Calculates game results and sorts them by points in descending order.\r\n */\r\nexport const calculateGameResults = (allPlayers: Map<string, PlayerInfo>, gameRounds: GameRound[]): GameResultForPlayer[] => {\r\n    const gameResults: GameResultForPlayer[] = [];\r\n    const pointsPerPlayer: Collection<GameResultForPlayer> = {};\r\n    allPlayers.forEach((playerInfo, playerId) => pointsPerPlayer[playerId] = { playerName: playerInfo.name, points: 0 });\r\n    gameRounds.forEach(round => {\r\n        round.forEach((playerInputs, playerId) => {\r\n            const points = playerInputs.reduce((total, input) => total + input.points, 0);\r\n            pointsPerPlayer[playerId].points += points;\r\n        });\r\n    });\r\n    Object.keys(pointsPerPlayer).forEach(playerId => gameResults.push(pointsPerPlayer[playerId]));\r\n    return gameResults.sort((a, b) => b.points - a.points);\r\n};\r\n\r\n/**\r\n * Creates a list of entries for the \"Hall of Fame\", the list of answers marked as \"very creative\".\r\n */\r\nexport const createHallOfFameData = (allPlayers: Map<string, PlayerInfo>, gameConfig: GameConfig, gameRounds: GameRound[]): HallOfFameEntry[] => {\r\n    const hallOfFameData: HallOfFameEntry[] = [];\r\n    gameRounds.forEach(round => {\r\n        round.forEach((playerInputs, playerId) => {\r\n            const playerInfo = allPlayers.get(playerId) as PlayerInfo;\r\n            playerInputs.forEach((playerInput, categoryIndex) => {\r\n                if (playerInput.valid && playerInput.star) {\r\n                    hallOfFameData.push({\r\n                        category: gameConfig.categories[categoryIndex],\r\n                        playerName: playerInfo.name,\r\n                        text: playerInput.text\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    });\r\n    return hallOfFameData;\r\n};\r\n","import React from 'react';\r\nimport { GAME_OPTION_LABEL } from '../../constants/game.constant';\r\nimport { GameConfigScoringOptions } from '../../models/game.interface';\r\n\r\ninterface ScoringOptionsListProps {\r\n    rules: GameConfigScoringOptions;\r\n}\r\n\r\nconst ScoringOptionsList: React.FunctionComponent<ScoringOptionsListProps> = props => {\r\n    const { rules } = props;\r\n    const createFurtherOptionsElement = (): JSX.Element => (\r\n        <React.Fragment>\r\n            <p className=\"bold-text\">Regeln für die Punktevergabe:</p>\r\n            <ul>\r\n                {rules.checkForDuplicates ? <li>{GAME_OPTION_LABEL.checkForDuplicates}</li> : null}\r\n                {rules.onlyPlayerWithValidAnswer ? <li>{GAME_OPTION_LABEL.onlyPlayerWithValidAnswer}</li> : null}\r\n                {rules.creativeAnswersExtraPoints ? <li>{GAME_OPTION_LABEL.creativeAnswersExtraPoints}</li> : null}\r\n            </ul>\r\n        </React.Fragment>\r\n    );\r\n    if (rules.checkForDuplicates || rules.onlyPlayerWithValidAnswer || rules.creativeAnswersExtraPoints) {\r\n        return createFurtherOptionsElement();\r\n    }\r\n    return null;\r\n}\r\n\r\nexport default ScoringOptionsList;\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"link_label\":\"JoinGameLink_link_label__1tx1j\"};","import { GamePhase } from '../constants/game.constant';\r\nimport { Collection } from './collection.interface';\r\nimport { EvaluationOfPlayerInput, GameConfig, IsPlayerInputVeryCreativeStatus, PlayerInput } from './game.interface';\r\nimport { PlayerInfo } from './player.interface';\r\n\r\nexport interface PubNubUserState {\r\n    gameConfig?: GameConfig;\r\n    playerInfo: PlayerInfo;\r\n}\r\n\r\nexport enum PubNubMessageType {\r\n    currentRoundInputs = 'currentRoundInputs',\r\n    dataForCurrentGame = 'dataForCurrentGame',\r\n    evaluationFinished = 'evaluationFinished',\r\n    evaluationOfPlayerInput = 'evaluationOfPlayerInput',\r\n    isPlayerInputVeryCreative = 'isPlayerInputVeryCreative',\r\n    kickPlayer = 'kickPlayer',\r\n    requestGameData = 'requestGameData',\r\n    roundFinished = 'roundFinished',\r\n    startGame = 'startGame'\r\n}\r\n\r\nexport interface PubNubMessage {\r\n    type: PubNubMessageType;\r\n    payload?: any;\r\n}\r\n\r\nexport class PubNubCurrentRoundInputsMessage {\r\n    constructor(private payload: PlayerInput[]) {}\r\n\r\n    public toPubNubMessage(): PubNubMessage {\r\n        return {\r\n            type: PubNubMessageType.currentRoundInputs,\r\n            payload: this.payload\r\n        };\r\n    }\r\n}\r\n\r\nexport class PubNubEvaluationOfPlayerInputMessage {\r\n    constructor(private payload: EvaluationOfPlayerInput) {}\r\n\r\n    public toPubNubMessage(): PubNubMessage {\r\n        return {\r\n            type: PubNubMessageType.evaluationOfPlayerInput,\r\n            payload: this.payload\r\n        };\r\n    }\r\n}\r\n\r\nexport class PubNubIsPlayerInputVeryCreativeMessage {\r\n    constructor(private payload: IsPlayerInputVeryCreativeStatus) {}\r\n\r\n    public toPubNubMessage(): PubNubMessage {\r\n        return {\r\n            type: PubNubMessageType.isPlayerInputVeryCreative,\r\n            payload: this.payload\r\n        };\r\n    }\r\n}\r\n\r\nexport class PubNubKickPlayerMessage {\r\n    constructor(private payload: string) {}\r\n\r\n    public toPubNubMessage(): PubNubMessage {\r\n        return {\r\n            type: PubNubMessageType.kickPlayer,\r\n            payload: this.payload\r\n        };\r\n    }\r\n}\r\n\r\nexport interface PubNubDataForCurrentGameMessagePayload {\r\n    compressedGameRoundEvaluation: boolean[][][];\r\n    compressedMarkedAsCreativeFlags: boolean[][];\r\n    currentPhase: GamePhase;\r\n    currentRound: number;\r\n    playersThatFinishedEvaluation: Collection<boolean>;\r\n    requestingPlayerId: string;\r\n    sortedPlayers: PlayerInfo[];\r\n}\r\nexport class PubNubDataForCurrentGameMessage {\r\n    constructor(private payload: PubNubDataForCurrentGameMessagePayload) {}\r\n\r\n    public toPubNubMessage(): PubNubMessage {\r\n        return {\r\n            type: PubNubMessageType.dataForCurrentGame,\r\n            payload: this.payload\r\n        };\r\n    }\r\n}\r\n","import {\r\n    Button,\r\n    Dialog,\r\n    DialogActions,\r\n    DialogContent,\r\n    DialogContentText,\r\n    IconButton,\r\n    ListItemIcon,\r\n    ListItemText,\r\n    Menu,\r\n    MenuItem,\r\n} from '@material-ui/core';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport CancelIcon from '@material-ui/icons/Cancel';\r\nimport SettingsIcon from '@material-ui/icons/Settings';\r\nimport React, { useState } from 'react';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { getPlayersInAlphabeticalOrder } from '../../utils/game.utils';\r\n\r\nconst useStyles = makeStyles({\r\n    adminPanel: {\r\n        position: 'absolute',\r\n        top: '1rem',\r\n        right: '1rem'\r\n    },\r\n    menuButton: {\r\n        background: 'radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,255,0.5) 35%, rgba(255,255,255,0) 60%);'\r\n    },\r\n    dialogContent: {\r\n        maxWidth: '23rem'\r\n    },\r\n    dialogContentText: {\r\n        color: 'black'\r\n    }\r\n});\r\n\r\nexport interface KickUserDialogProps {\r\n    open: boolean;\r\n    playerToBeKicked: PlayerInfo | null;\r\n    onClose: (kickPlayer: boolean) => void;\r\n}\r\nconst KickUserDialog: React.FunctionComponent<KickUserDialogProps> = props => {\r\n    const classes = useStyles();\r\n    const { onClose, open } = props;\r\n\r\n    return (\r\n        <Dialog onClose={() => onClose(false)} open={open}>\r\n            <DialogContent classes={{ root: classes.dialogContent }}>\r\n                {props.playerToBeKicked ? (\r\n                    <DialogContentText classes={{ root: classes.dialogContentText }}>\r\n                        \"With great power comes great responsibility\" – Willst du {props.playerToBeKicked.name} wirklich aus dem Spiel werfen?\r\n                    </DialogContentText>\r\n                ) : null}\r\n            </DialogContent>\r\n            <DialogActions>\r\n                <Button\r\n                    type=\"button\"\r\n                    onClick={() => onClose(false)}\r\n                >Abbrechen</Button>\r\n                <Button\r\n                    type=\"button\"\r\n                    color=\"primary\"\r\n                    onClick={() => onClose(true)}\r\n                >Rauswerfen</Button>\r\n            </DialogActions>\r\n        </Dialog>\r\n    );\r\n}\r\n\r\ninterface AdminPanelProps {\r\n    allPlayers: Map<string, PlayerInfo>;\r\n    kickPlayer: (playerId: string) => void;\r\n}\r\nconst AdminPanel: React.FunctionComponent<AdminPanelProps> = props => {\r\n    const classes = useStyles();\r\n    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\r\n    const [openDialog, setOpenDialog] = useState(false);\r\n    const [playerToBeKicked, setPlayerToBeKicked] = useState<PlayerInfo | null>(null);\r\n\r\n    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n        setAnchorEl(event.currentTarget);\r\n    };\r\n    const handleMenuItemClick = (selectedPlayer: PlayerInfo) => {\r\n        setAnchorEl(null);\r\n        setPlayerToBeKicked(selectedPlayer);\r\n        setOpenDialog(true);\r\n    };\r\n    const handleAdminPanelClose = () => {\r\n        setAnchorEl(null);\r\n    };\r\n    const handleKickUserDialogClose = (kickPlayer: boolean) => {\r\n        setOpenDialog(false);\r\n        if (kickPlayer && playerToBeKicked) {\r\n            props.kickPlayer(playerToBeKicked.id);\r\n        }\r\n    };\r\n\r\n    const otherPlayers = new Map<string, PlayerInfo>();\r\n    props.allPlayers.forEach((playerInfo, playerId) => {\r\n        if (!playerInfo.isAdmin) { otherPlayers.set(playerId, playerInfo); }\r\n    });\r\n    const sortedPlayers = getPlayersInAlphabeticalOrder(otherPlayers);\r\n    return (\r\n        <div className={classes.adminPanel}>\r\n            <IconButton\r\n                className={classes.menuButton}\r\n                title=\"Admin-Panel öffnen\"\r\n                aria-label=\"Admin-Panel öffnen\"\r\n                aria-controls=\"admin-panel\"\r\n                aria-haspopup=\"true\"\r\n                onClick={handleClick}\r\n            >\r\n                <SettingsIcon color=\"primary\" />\r\n            </IconButton>\r\n            <Menu\r\n                id=\"admin-panel\"\r\n                anchorEl={anchorEl}\r\n                keepMounted\r\n                open={Boolean(anchorEl)}\r\n                onClose={handleAdminPanelClose}\r\n            >\r\n                {sortedPlayers.map((playerInfo, playerIndex) => (\r\n                    <MenuItem\r\n                        key={`menu-item-delete-player-${playerIndex}`}\r\n                        title={`${playerInfo.name} aus dem Spiel werfen`}\r\n                        onClick={() => handleMenuItemClick(playerInfo)}\r\n                    >\r\n                        <ListItemIcon>\r\n                            <CancelIcon color=\"secondary\" />\r\n                        </ListItemIcon>\r\n                        <ListItemText primary={playerInfo.name} />\r\n                    </MenuItem>\r\n                ))}\r\n            </Menu>\r\n            <KickUserDialog\r\n                open={openDialog}\r\n                playerToBeKicked={playerToBeKicked}\r\n                onClose={handleKickUserDialogClose}\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default AdminPanel;\r\n","import './LetterAnimation.css';\r\nimport React, { useEffect } from 'react';\r\nimport {\r\n    LETTER_ANIMATION_LETTER_COUNT,\r\n    LETTER_ANIMATION_REDRAW_SPEED,\r\n    STANDARD_ALPHABET,\r\n} from '../../constants/game.constant';\r\nimport { AppTheme, AppThemes } from '../../constants/themes.constant';\r\nimport { getRandomnLetters } from '../../utils/game.utils';\r\n\r\n// Thanks to Georgi Nikoloff for the great animation source code: https://codepen.io/gbnikolov/pen/jEqQdG\r\n// I rewrote the code in Typescript, refactored it a bit and adapted it to the needs of this application.\r\n\r\nclass Particle {\r\n    private radius = 3.5;\r\n\r\n    constructor(\r\n        public x: number,\r\n        public y: number\r\n    ) { }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.translate(this.x, this.y);\r\n        ctx.fillStyle = 'white';\r\n        ctx.fillRect(0, 0, this.radius, this.radius);\r\n        ctx.restore();\r\n    };\r\n}\r\n\r\nclass ParticleAlphabet {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n    private currentPos: number;\r\n    private width: number;\r\n    private height: number;\r\n    private particlePositions: any[];\r\n    private particles: Particle[];\r\n    private tmpCanvas: HTMLCanvasElement;\r\n    private tmpCtx: CanvasRenderingContext2D;\r\n    private time: string;\r\n    private counter = 0;\r\n    private myInterval: any;\r\n    private activeTheme: AppTheme;\r\n\r\n    constructor(\r\n        public letters: string[],\r\n        public callbackWhenAnimationDone: () => void\r\n    ) {\r\n        this.canvas = document.querySelector('#letter-animation-canvas') as HTMLCanvasElement;\r\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\r\n        const mainElement = document.querySelector('main') as HTMLElement;\r\n        this.activeTheme = AppThemes.find(theme => mainElement.classList.contains(theme.className)) as AppTheme;\r\n        this.width = mainElement.offsetWidth;\r\n        this.height = mainElement.offsetHeight;\r\n        this.particlePositions = [];\r\n        this.particles = [];\r\n        this.tmpCanvas = document.createElement('canvas');\r\n        this.tmpCtx = this.tmpCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n\r\n        this.canvas.width = this.width;\r\n        this.canvas.height = this.height;\r\n        this.particlePositions = [];\r\n        this.currentPos = 0;\r\n        this.time = '';\r\n    }\r\n\r\n    public init() {\r\n        this.myInterval = setInterval(() => {\r\n            if (this.counter < this.letters.length) {\r\n                this.changeLetter();\r\n                this.getPixels(this.tmpCanvas, this.tmpCtx);\r\n            }\r\n            this.counter++;\r\n            if (this.counter > this.letters.length + 1) {\r\n                clearInterval(this.myInterval);\r\n                this.callbackWhenAnimationDone();\r\n            }\r\n        }, LETTER_ANIMATION_REDRAW_SPEED);\r\n\r\n        this.makeParticles(1000);\r\n        this.animate();\r\n    }\r\n\r\n    private changeLetter() {\r\n        this.time = this.letters[this.currentPos];\r\n        this.currentPos++;\r\n        if (this.currentPos >= this.letters.length) {\r\n            this.currentPos = 0;\r\n        }\r\n    }\r\n\r\n    private makeParticles(num: number) {\r\n        for (var i = 0; i <= num; i++) {\r\n            const x = this.width / 2 + Math.random() * 400 - 200;\r\n            const y = this.height / 2 + Math.random() * 400 - 200;\r\n            this.particles.push(new Particle(x, y));\r\n        }\r\n    }\r\n\r\n    private getPixels(canvas: any, ctx: any) {\r\n        const keyword = this.time,\r\n            gridX = 6,\r\n            gridY = 6;\r\n        canvas.width = window.innerWidth;\r\n        canvas.height = window.innerHeight;\r\n        ctx.fillStyle = 'red';\r\n        ctx.font = 'italic bold 330px Noto Serif';\r\n        ctx.fillText(keyword, canvas.width / 2 - ctx.measureText(keyword).width / 2, canvas.height / 2 + 100);\r\n        const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n        const buffer32 = new Uint32Array(idata.data.buffer);\r\n        if (this.particlePositions.length > 0) this.particlePositions = [];\r\n        for (let y = 0; y < canvas.height; y += gridY) {\r\n            for (let x = 0; x < canvas.width; x += gridX) {\r\n                if (buffer32[y * canvas.width + x]) {\r\n                    this.particlePositions.push({ x: x, y: y });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private animateParticles() {\r\n        let p, pPos;\r\n        for (let i = 0, num = this.particles.length; i < num; i++) {\r\n            p = this.particles[i];\r\n            pPos = this.particlePositions[i];\r\n            if (this.particles.indexOf(p) === this.particlePositions.indexOf(pPos)) {\r\n                p.x += (pPos.x - p.x) * .3;\r\n                p.y += (pPos.y - p.y) * .3;\r\n                p.draw(this.ctx);\r\n            }\r\n        }\r\n    }\r\n\r\n    private animate = () => {\r\n        requestAnimationFrame(this.animate);\r\n        this.ctx.fillStyle = this.activeTheme.animationBackgroundColor;\r\n        this.ctx.fillRect(0, 0, this.width, this.height);\r\n        this.animateParticles();\r\n    }\r\n}\r\n\r\ninterface LetterAnimationProps {\r\n    letterToUnveil: string;\r\n    callbackWhenAnimationDone: () => void;\r\n}\r\nexport const LetterAnimation: React.FunctionComponent<LetterAnimationProps> = props => {\r\n    const lettersToUse = [...STANDARD_ALPHABET].filter(letter => letter !== props.letterToUnveil);\r\n    const lettersForAnimation = [...getRandomnLetters(LETTER_ANIMATION_LETTER_COUNT - 1, lettersToUse), props.letterToUnveil];\r\n    useEffect(() => {\r\n        const particleAlphabet = new ParticleAlphabet(lettersForAnimation, props.callbackWhenAnimationDone);\r\n        particleAlphabet.init();\r\n    });\r\n    return (\r\n        <canvas id=\"letter-animation-canvas\"></canvas>\r\n    );\r\n}\r\n","import Chip from '@material-ui/core/Chip';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport EmojiObjectsIcon from '@material-ui/icons/EmojiObjects';\r\nimport React from 'react';\r\n\r\nconst useStyles = makeStyles({\r\n    centerContent: {\r\n        display: 'flex',\r\n        justifyContent: 'center'\r\n    },\r\n    chip: {\r\n        height: '3rem',\r\n        marginTop: '1rem',\r\n        borderRadius: '5px',\r\n        fontSize: '1.2rem',\r\n        boxShadow: '0 2px 4px rgba(0,0,0,.501961)'\r\n    }\r\n});\r\n\r\ninterface GameRoundChipProps {\r\n    currentLetter: string;\r\n    currentRound: number;\r\n    numberOfRounds: number;\r\n}\r\n\r\nconst GameRoundChip: React.FunctionComponent<GameRoundChipProps> = props => {\r\n    const classes = useStyles();\r\n    const { currentLetter, currentRound, numberOfRounds } = props;\r\n    return (\r\n        <div className={classes.centerContent}>\r\n            <Chip\r\n                color=\"primary\"\r\n                icon={<EmojiObjectsIcon />}\r\n                label={`Runde ${currentRound} von ${numberOfRounds}: „${currentLetter}“`}\r\n                className={classes.chip}\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameRoundChip;\r\n","import './PhaseEvaluateRound.css';\r\nimport {\r\n    Badge,\r\n    Chip,\r\n    createStyles,\r\n    IconButton,\r\n    InputAdornment,\r\n    Snackbar,\r\n    TextField,\r\n    Theme,\r\n    Tooltip,\r\n    withStyles,\r\n} from '@material-ui/core';\r\nimport CheckCircleIcon from '@material-ui/icons/CheckCircle';\r\nimport RadioButtonUncheckedIcon from '@material-ui/icons/RadioButtonUnchecked';\r\nimport SearchIcon from '@material-ui/icons/Search';\r\nimport StarIcon from '@material-ui/icons/Star';\r\nimport StarBorderIcon from '@material-ui/icons/StarBorder';\r\nimport ThumbDownRoundedIcon from '@material-ui/icons/ThumbDownRounded';\r\nimport React, { useState } from 'react';\r\nimport { EXTRA_POINTS } from '../../constants/game.constant';\r\nimport {\r\n    EvaluationOfPlayerInput,\r\n    GameConfig,\r\n    GameRound,\r\n    GameRoundEvaluation,\r\n    IsPlayerInputVeryCreativeStatus,\r\n    PlayerInput,\r\n    PlayerInputEvaluation,\r\n} from '../../models/game.interface';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { getPlayersInAlphabeticalOrder, getRejectingPlayers } from '../../utils/game.utils';\r\nimport GameRoundChip from '../GameRoundChip/GameRoundChip';\r\nimport { SectionHeader } from '../SectionHeader/SectionHeader';\r\n\r\nconst StyledBadge = withStyles((theme: Theme) =>\r\n    createStyles({\r\n        badge: {\r\n            right: -3,\r\n            top: '100%',\r\n            border: `2px solid ${theme.palette.background.paper}`,\r\n            padding: '0 4px',\r\n        },\r\n    }),\r\n)(Badge);\r\n\r\ninterface PhaseEvaluateRoundProps {\r\n    allPlayers: Map<string, PlayerInfo>;\r\n    currentRound: number;\r\n    currentRoundEvaluation: GameRoundEvaluation;\r\n    gameConfig: GameConfig;\r\n    gameRounds: GameRound[];\r\n    /** Player info for the user of this instance of the \"Stadt-Land-Fluss\" app. */\r\n    playerInfo: PlayerInfo;\r\n    playersThatFinishedEvaluation: Map<string, boolean>;\r\n    sendEvaluationFinishedMessage: () => void;\r\n    updateEvaluationOfPlayerInput: (newEvaluation: EvaluationOfPlayerInput) => void;\r\n    updateIsPlayerInputVeryCreativeStatus: (newStatus: IsPlayerInputVeryCreativeStatus) => void;\r\n}\r\nconst PhaseEvaluateRound: React.FunctionComponent<PhaseEvaluateRoundProps> = props => {\r\n    const [hasFinishedEvaluation, setHasFinishedEvaluation] = useState(props.playersThatFinishedEvaluation.has(props.playerInfo.id));\r\n    const [isSnackbarOpen, setIsSnackbarOpen] = useState(false);\r\n    const [snackBarMessage, setSnackBarMessage] = useState('');\r\n    const { allPlayers, currentRound, currentRoundEvaluation, gameConfig, playerInfo, playersThatFinishedEvaluation } = props;\r\n    // Retrieve data for finished round; e.g. if current round is 1, then data is at index 0.\r\n    const finishedRound = props.gameRounds[currentRound - 1];\r\n    const currentLetter = gameConfig.letters[currentRound - 1];\r\n    const sortedPlayers = getPlayersInAlphabeticalOrder(allPlayers);\r\n    const notFinishedPlayers: string[] = [];\r\n    sortedPlayers.forEach(player => {\r\n        if (!playersThatFinishedEvaluation.has(player.id)) { notFinishedPlayers.push(player.name); }\r\n    });\r\n\r\n    const showSnackBar = (message: string) => {\r\n        setSnackBarMessage(message);\r\n        setIsSnackbarOpen(true);\r\n    }\r\n    const handleSnackBarClose = () =>  setIsSnackbarOpen(false);\r\n    /**\r\n      * Toggles the user's evaluation of a player's input for a category,\r\n      * but only if the user hasn't accepted the round evaluation yet.\r\n      */\r\n    const handleEvaluationButtonClick = (\r\n        categoryIndex: number, evaluatedPlayerId: string, currentEvaluation: boolean\r\n    ) => {\r\n        if (hasFinishedEvaluation) {\r\n            showSnackBar('Du hast bereits die Bewertung der Runde bestätigt!');\r\n        } else {\r\n            props.updateEvaluationOfPlayerInput({ categoryIndex, evaluatedPlayerId, markedAsValid: !currentEvaluation });\r\n        }\r\n    }\r\n    /**\r\n     * Displays a button that allows the user to reject a player's input for a category.\r\n     * A badge attached to the button shows the total number of rejections. If the player\r\n     * didn't type any text, then a not clickable thumb down icon is shown instead,\r\n     * which indicates that the input was automatically rejected by the application.\r\n     */\r\n    const createEvaluationButton = (categoryIndex: number, indexInSortedPlayers: number): JSX.Element => {\r\n        const evaluatedPlayer = sortedPlayers[indexInSortedPlayers];\r\n        const allEvaluationsForPlayer = currentRoundEvaluation.get(evaluatedPlayer.id) as PlayerInputEvaluation[];\r\n        const evaluationForCategory = allEvaluationsForPlayer[categoryIndex];\r\n        const isInputAcceptedByUser = evaluationForCategory.get(playerInfo.id) as boolean;\r\n        const rejectingPlayers = getRejectingPlayers(evaluationForCategory, allPlayers);\r\n        const tooltipText = rejectingPlayers.length === 0 ? 'Keine Ablehnungen' :\r\n            'Abgelehnt von ' + rejectingPlayers.map(p => p.name).join(', ');\r\n        const hasPlayerTypedText = !!(finishedRound.get(evaluatedPlayer.id) as PlayerInput[])[categoryIndex].text;\r\n\r\n        const evaluationButtonForTypedText = (\r\n            <Tooltip\r\n                key={`slf-evaluation-tooltip-${categoryIndex}-${indexInSortedPlayers}`}\r\n                title={tooltipText}\r\n            >\r\n                <IconButton\r\n                    className=\"slf-evaluation-button\"\r\n                    color={isInputAcceptedByUser ? 'default' : 'secondary'}\r\n                    onClick={() => handleEvaluationButtonClick(categoryIndex, evaluatedPlayer.id, isInputAcceptedByUser)}\r\n                >\r\n                    <StyledBadge badgeContent={rejectingPlayers.length} color=\"secondary\">\r\n                        <ThumbDownRoundedIcon />\r\n                    </StyledBadge>\r\n                </IconButton>\r\n            </Tooltip>\r\n        );\r\n        const autoRejectIconForMissingText = (\r\n            <Tooltip\r\n                key={`slf-evaluation-tooltip-${categoryIndex}-${indexInSortedPlayers}`}\r\n                title=\"Automatisch abgelehnt\"\r\n            >\r\n                <ThumbDownRoundedIcon color=\"secondary\" className=\"slf-auto-reject-icon\" />\r\n            </Tooltip>\r\n        );\r\n\r\n        return (\r\n            <div\r\n                key={`slf-evaluation-button-wrapper-${categoryIndex}-${indexInSortedPlayers}`}\r\n                className=\"slf-evaluation-button-wrapper\"\r\n            >\r\n                {hasPlayerTypedText ? evaluationButtonForTypedText : autoRejectIconForMissingText}\r\n            </div>\r\n        );\r\n    }\r\n    /**\r\n     * Creates a search link for a specific category and player input.\r\n     */\r\n    const createSearchLink = (categoryIndex: number, indexInSortedPlayers: number): JSX.Element => {\r\n        const category = gameConfig.categories[categoryIndex];\r\n        const evaluatedPlayer = sortedPlayers[indexInSortedPlayers];\r\n        const playerInput = (finishedRound.get(evaluatedPlayer.id) as PlayerInput[])[categoryIndex].text;\r\n        const searchLink = `https://www.ecosia.org/search?q=${encodeURIComponent(category)}+${encodeURIComponent(playerInput)}`\r\n        return (\r\n            <a\r\n                className=\"slf-evaluation-search-link\"\r\n                href={searchLink}\r\n                target=\"_blank\"\r\n                rel=\"noopener noreferrer\"\r\n                aria-label=\"Begriff nachschlagen\"\r\n            >\r\n                <Tooltip\r\n                    title=\"Begriff nachschlagen\"\r\n                    placement=\"bottom\"\r\n                >\r\n                    <SearchIcon color=\"primary\" fontSize=\"small\" />\r\n                </Tooltip>\r\n            </a>\r\n        );\r\n    }\r\n    /**\r\n      * Toggles the \"marked as very creative\" status of a player's input for a category,\r\n      * but only if the user hasn't accepted the round evaluation yet and isn't trying to mark their own answer as \"very creative\".\r\n      */\r\n    const handleMarkAsCreativeAnswerToggleClick = (\r\n        categoryIndex: number, evaluatedPlayerId: string, isMarkedAsCreative: boolean\r\n    ) => {\r\n        if (hasFinishedEvaluation) {\r\n            showSnackBar('Du hast bereits die Bewertung der Runde bestätigt!');\r\n        } else {\r\n            if (props.playerInfo.id === evaluatedPlayerId) {\r\n                showSnackBar('Nice try! Ob deine eigene Antwort sehr kreativ oder lustig ist, sollen die anderen beurteilen.');\r\n            } else {\r\n                props.updateIsPlayerInputVeryCreativeStatus({ categoryIndex, evaluatedPlayerId, markedAsCreative: !isMarkedAsCreative });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates a \"mark as creative answer\" toggle button for a specific category and player input.\r\n     */\r\n    const createMarkAsCreativeAnswerToggle = (categoryIndex: number, indexInSortedPlayers: number): JSX.Element => {\r\n        const evaluatedPlayer = sortedPlayers[indexInSortedPlayers];\r\n        const playerInput = (finishedRound.get(evaluatedPlayer.id) as PlayerInput[])[categoryIndex];\r\n        return (\r\n            <Tooltip\r\n                title={playerInput.star ? 'Besonders kreativ? Nope!' : 'Als besonders kreativ markieren'}\r\n                placement=\"bottom\"\r\n            >\r\n                <IconButton\r\n                    className=\"slf-mark-as-creative-button\"\r\n                    color=\"primary\"\r\n                    size=\"small\"\r\n                    onClick={() => handleMarkAsCreativeAnswerToggleClick(categoryIndex, evaluatedPlayer.id, playerInput.star)}\r\n                >\r\n                    {playerInput.star ? <StarIcon /> : <StarBorderIcon />}\r\n                </IconButton>\r\n            </Tooltip>\r\n        );\r\n    }\r\n    const createPointsChip = (evaluatedPlayerInput: PlayerInput): JSX.Element => {\r\n        const points = gameConfig.scoringOptions.creativeAnswersExtraPoints && evaluatedPlayerInput.star\r\n            ? evaluatedPlayerInput.points + EXTRA_POINTS : evaluatedPlayerInput.points;\r\n        return <Chip label={`+${points}`} color=\"primary\" />;\r\n    }\r\n    /**\r\n     * Creates a text input showing the player's input for a category. If the player input isn't an empty string,\r\n     * then on the right side of the textfield a search link and clickable evaluation button are displayed.\r\n     */\r\n    const playerEvaluationElements = (categoryIndex: number, indexInSortedPlayers: number): JSX.Element => {\r\n        const evaluatedPlayer = sortedPlayers[indexInSortedPlayers];\r\n        const evaluatedPlayerInput = (finishedRound.get(evaluatedPlayer.id) as PlayerInput[])[categoryIndex];\r\n        const hasPlayerTypedText = !!evaluatedPlayerInput.text;\r\n        const isInputValid = evaluatedPlayerInput.valid;\r\n        const inputCssClass = isInputValid ? (evaluatedPlayerInput.star ? 'very-creative-player-input' : '') : 'invalid-player-input';\r\n        return (\r\n            <div\r\n                key={`slf-evaluation-textfield-wrapper-${categoryIndex}-${indexInSortedPlayers}`}\r\n                className=\"slf-evaluation-textfield-wrapper\"\r\n            >\r\n                <TextField\r\n                    key={'slf-textfield-category-no-' + categoryIndex + '-player-' + indexInSortedPlayers}\r\n                    value={evaluatedPlayerInput.text}\r\n                    variant=\"outlined\"\r\n                    fullWidth\r\n                    InputProps={{\r\n                        className: inputCssClass,\r\n                        spellCheck: false,\r\n                        startAdornment: <InputAdornment position=\"start\">{evaluatedPlayer.name}:</InputAdornment>,\r\n                        endAdornment: <InputAdornment position=\"end\">\r\n                            <div className=\"slf-evaluation-textfield-end-adornment\">\r\n                                {hasPlayerTypedText ? createSearchLink(categoryIndex, indexInSortedPlayers) : null}\r\n                                {isInputValid ? createMarkAsCreativeAnswerToggle(categoryIndex, indexInSortedPlayers) : null}\r\n                                {isInputValid ? createPointsChip(evaluatedPlayerInput) : null}\r\n                            </div>\r\n                        </InputAdornment>\r\n                    }}\r\n                />\r\n                {createEvaluationButton(categoryIndex, indexInSortedPlayers)}\r\n            </div>\r\n        );\r\n    }\r\n    /**\r\n     * Creates a section for each category of the current game. It displays the category in the header,\r\n     * followed by one textfield for each player showing their input for the finished round.\r\n     * If the input isn't empty, a search link and clickable evaluation button are displayed.\r\n     */\r\n    const createCategorySection = (category: string, categoryIndex: number): JSX.Element => (\r\n        <div\r\n            key={'slf-evaluation-for-category-no-' + categoryIndex}\r\n            className=\"material-card-style\"\r\n        >\r\n            <SectionHeader showDivider={false} text={category}></SectionHeader>\r\n            {sortedPlayers.map((_, indexInSortedPlayers) => playerEvaluationElements(categoryIndex, indexInSortedPlayers))}\r\n        </div>\r\n    );\r\n    const onAcceptEvaluationButtonClick = () => {\r\n        if (!hasFinishedEvaluation) {\r\n            setHasFinishedEvaluation(true);\r\n            props.sendEvaluationFinishedMessage();\r\n        }\r\n    }\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <GameRoundChip\r\n                currentLetter={currentLetter}\r\n                currentRound={currentRound}\r\n                numberOfRounds={gameConfig.numberOfRounds}\r\n            />\r\n            <form className=\"app-form\" noValidate autoComplete=\"off\">\r\n                {gameConfig.categories.map(createCategorySection)}\r\n                <div className=\"material-card-style\">\r\n                    Bestätigung ausstehend: <span className=\"bold-text\">{notFinishedPlayers.join(', ')}</span>\r\n                </div>\r\n                <IconButton\r\n                    type=\"button\"\r\n                    className=\"fixed-bottom-right-button\"\r\n                    color=\"secondary\"\r\n                    title=\"Bestätigen\"\r\n                    aria-label=\"Bestätigen\"\r\n                    onClick={onAcceptEvaluationButtonClick}\r\n                >\r\n                    {hasFinishedEvaluation ? <CheckCircleIcon /> : <RadioButtonUncheckedIcon />}\r\n                </IconButton>\r\n            </form>\r\n            <Snackbar\r\n                anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}\r\n                open={isSnackbarOpen}\r\n                autoHideDuration={3000}\r\n                onClose={handleSnackBarClose}\r\n                message={snackBarMessage}\r\n            />\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default PhaseEvaluateRound;\r\n","import React from 'react';\r\nimport Countdown, { zeroPad } from 'react-countdown';\r\nimport { makeStyles, Theme, createStyles } from '@material-ui/core';\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n    createStyles({\r\n        countdown: {\r\n            position: 'fixed',\r\n            right: '1.5rem',\r\n            bottom: '1rem',\r\n            backgroundColor: theme.palette.primary.main,\r\n            color: theme.palette.primary.contrastText,\r\n            padding: '0.5rem 1rem',\r\n            fontSize: '1.5rem',\r\n            boxShadow: '0 2px 4px rgba(0, 0, 0, .401961)',\r\n            borderRadius: '5px',\r\n        },\r\n    }),\r\n);\r\n\r\ninterface RoundCountdownProps {\r\n    /** Duration of countdown in seconds */\r\n    duration: number;\r\n    /** The method to be called when countdown reaches zero */\r\n    onComplete: () => void;\r\n}\r\n\r\nconst RoundCountdown: React.FunctionComponent<RoundCountdownProps> = props => {\r\n    const classes = useStyles();\r\n    return (\r\n        <Countdown\r\n            date={Date.now() + (props.duration * 1000)}\r\n            renderer={props => (\r\n                <div className={classes.countdown}>\r\n                    {zeroPad(props.minutes)}:{zeroPad(props.seconds)}\r\n                </div>\r\n            )}\r\n            onComplete={props.onComplete}\r\n        />\r\n    );\r\n}\r\n\r\nexport default React.memo(RoundCountdown);\r\n","import { IconButton, InputAdornment, TextField } from '@material-ui/core';\r\nimport EmailIcon from '@material-ui/icons/Email';\r\nimport React, { ChangeEvent } from 'react';\r\nimport { GameConfig, PlayerInput } from '../../models/game.interface';\r\nimport GameRoundChip from '../GameRoundChip/GameRoundChip';\r\nimport RoundCountdown from '../RoundCountdown/RoundCountdown';\r\nimport { SectionHeader } from '../SectionHeader/SectionHeader';\r\n\r\ninterface PhaseFillOutTextfieldsProps {\r\n    currentRound: number;\r\n    gameConfig: GameConfig;\r\n    gameRoundInputs: PlayerInput[];\r\n    updateCurrentRoundInputs: (newCurrentRoundInputs: PlayerInput[]) => void;\r\n    finishRoundOnCountdownComplete: () => void;\r\n    finishRoundOnUserAction: () => void;\r\n}\r\n\r\nconst PhaseFillOutTextfields: React.FunctionComponent<PhaseFillOutTextfieldsProps> = props => {\r\n    const { currentRound, gameConfig, gameRoundInputs } = props;\r\n    const currentLetter = gameConfig.letters[currentRound - 1];\r\n\r\n    const handleInputChange = (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, index: number) => {\r\n        const newGameRoundInputs = [...gameRoundInputs];\r\n        newGameRoundInputs[index] = { ...newGameRoundInputs[index], text: event.target.value };\r\n        props.updateCurrentRoundInputs(newGameRoundInputs);\r\n    };\r\n    const createTextfieldElement = (category: string, index: number): JSX.Element => (\r\n        <div\r\n            key={'slf-input-for-category-no-' + index}\r\n            className=\"material-card-style\"\r\n        >\r\n            <SectionHeader showDivider={false} text={category}></SectionHeader>\r\n            <TextField\r\n                value={gameRoundInputs[index].text}\r\n                onChange={event => handleInputChange(event, index)}\r\n                variant=\"outlined\"\r\n                fullWidth\r\n                InputProps={{\r\n                    startAdornment: <InputAdornment position=\"start\">{currentLetter}:</InputAdornment>,\r\n                    spellCheck: false\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n    const endRoundButton = (\r\n        <IconButton\r\n            type=\"button\"\r\n            className=\"fixed-bottom-right-button\"\r\n            color=\"secondary\"\r\n            title=\"Abschicken\"\r\n            aria-label=\"Abschicken\"\r\n            onClick={props.finishRoundOnUserAction}\r\n        >\r\n            <EmailIcon />\r\n        </IconButton>\r\n    );\r\n    const countdownElement = (\r\n        <RoundCountdown\r\n            duration={props.gameConfig.durationOfCountdown}\r\n            onComplete={props.finishRoundOnCountdownComplete}\r\n        />\r\n    );\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <GameRoundChip\r\n                currentLetter={currentLetter}\r\n                currentRound={currentRound}\r\n                numberOfRounds={gameConfig.numberOfRounds}\r\n            />\r\n            <form className=\"app-form\" noValidate autoComplete=\"off\">\r\n                {gameConfig.categories.map(createTextfieldElement)}\r\n                {gameConfig.useCountdown ? countdownElement : endRoundButton }\r\n            </form>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default PhaseFillOutTextfields;\r\n","import { IconButton, InputAdornment, OutlinedInput, Snackbar } from '@material-ui/core';\r\nimport FileCopyIcon from '@material-ui/icons/FileCopy';\r\nimport React, { useState } from 'react';\r\nimport { copyToClipboard } from '../../utils/general.utils';\r\nimport styles from './JoinGameLink.module.css';\r\n\r\ninterface JoinGameLinkProps {\r\n    gameId: string;\r\n}\r\n\r\nexport const JoinGameLink: React.FunctionComponent<JoinGameLinkProps> = props => {\r\n    const [open, setOpen] = useState(false);\r\n    const handleClick = () => {\r\n        copyToClipboard(joinGameLink)\r\n        setOpen(true);\r\n    };\r\n    const handleClose = () => {\r\n        setOpen(false);\r\n    };\r\n\r\n    const url = window.location.href;\r\n    // Cut off \"/play\" from the end of the url and add route plus game id.\r\n    const joinGameLink = url.slice(0, url.length - 5) + '/joingame?id=' + props.gameId;\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <p className={styles.link_label}>Teile diesen Link mit Freunden:</p>\r\n            <OutlinedInput\r\n                name=\"idInput\"\r\n                value={joinGameLink}\r\n                className=\"app-form-input\"\r\n                disabled\r\n                fullWidth\r\n                endAdornment={\r\n                    <InputAdornment position=\"end\">\r\n                        <IconButton\r\n                            title=\"Link kopieren\"\r\n                            aria-label=\"Link kopieren\"\r\n                            onClick={handleClick}\r\n                        >\r\n                            <FileCopyIcon />\r\n                        </IconButton>\r\n                    </InputAdornment>\r\n                }\r\n            />\r\n            <Snackbar\r\n                anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}\r\n                open={open}\r\n                autoHideDuration={1500}\r\n                onClose={handleClose}\r\n                message=\"Der Link wurde in Zwischenablage kopiert.\"\r\n            />\r\n        </React.Fragment>\r\n    );\r\n}\r\n","import Chip from '@material-ui/core/Chip';\r\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\r\nimport FaceIcon from '@material-ui/icons/Face';\r\nimport React from 'react';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { getPlayersInAlphabeticalOrder } from '../../utils/game.utils';\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n    createStyles({\r\n        root: {\r\n            display: 'flex',\r\n            flexWrap: 'wrap',\r\n            padding: theme.spacing(0.5),\r\n        },\r\n        chip: {\r\n            margin: theme.spacing(0.5),\r\n        },\r\n    }),\r\n);\r\n\r\ninterface PlayerListProps {\r\n    players: Map<string, PlayerInfo>;\r\n}\r\nconst PlayerList: React.FunctionComponent<PlayerListProps> = props => {\r\n    const classes = useStyles();\r\n    const sortedPlayers = getPlayersInAlphabeticalOrder(props.players);\r\n    return (\r\n        <div className={classes.root}>\r\n            {sortedPlayers.map((playerInfo, index) => (\r\n                <Chip\r\n                    key={`player-name-${index}`}\r\n                    icon={<FaceIcon />}\r\n                    color={playerInfo.isAdmin ? 'secondary' : 'primary'}\r\n                    label={playerInfo.isAdmin ? `${playerInfo.name} (Admin)` : playerInfo.name}\r\n                    className={classes.chip}\r\n                />\r\n            ))}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default PlayerList;\r\n","import './PhaseWaitingToStart.css';\r\nimport { Button, Divider } from '@material-ui/core';\r\nimport PlayCircleFilled from '@material-ui/icons/PlayCircleFilled';\r\nimport React from 'react';\r\nimport { MIN_NUMBER_OF_PLAYERS } from '../../constants/game.constant';\r\nimport { GameConfig } from '../../models/game.interface';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { PubNubMessage, PubNubMessageType } from '../../models/pub-nub-data.model';\r\nimport { JoinGameLink } from '../JoinGameLink/JoinGameLink';\r\nimport PlayerList from '../PlayerList/PlayerList';\r\nimport ScoringOptionsList from '../ScoringOptionsList/ScoringOptionsList';\r\nimport { SectionHeader } from '../SectionHeader/SectionHeader';\r\n\r\ninterface PhaseWaitingToStartProps {\r\n    allPlayers: Map<string, PlayerInfo>;\r\n    gameConfig: GameConfig | null;\r\n    gameId: string;\r\n    playerInfo: PlayerInfo;\r\n    sendMessage: (message: PubNubMessage) => void;\r\n}\r\n\r\nconst PhaseWaitingToStart: React.FunctionComponent<PhaseWaitingToStartProps> = props => {\r\n    const { allPlayers, gameId, playerInfo } = props;\r\n    const gameConfig = props.gameConfig as GameConfig;\r\n    const waitForGameStartElement = (\r\n        <p className=\"wait-for-start-animation\">Warte auf Spielbeginn <span>.</span><span>.</span><span>.</span></p>\r\n    );\r\n    const createGameSettingsElement = (): JSX.Element => (\r\n        <React.Fragment>\r\n            <Divider />\r\n            <h3>Spieleinstellungen:</h3>\r\n            <p><span className=\"bold-text\">ID:</span> {props.gameId}</p>\r\n            <p><span className=\"bold-text\">Runden:</span> {gameConfig.numberOfRounds}</p>\r\n            <p><span className=\"bold-text\">Kategorien:</span> {gameConfig.categories.join(', ')}</p>\r\n            <p>\r\n                <span className=\"bold-text\">Beenden der Runde durch:</span>\r\n                <span> {gameConfig.useCountdown ? `Countdown (${gameConfig.durationOfCountdown} Sekunden)` : 'Spieler'}</span>\r\n            </p>\r\n            <ScoringOptionsList rules={gameConfig.scoringOptions} />\r\n        </React.Fragment>\r\n    );\r\n    const createStartGameButton = (): JSX.Element => (\r\n        <div className=\"button-wrapper add-margin-top\">\r\n            <Button\r\n                color=\"primary\"\r\n                variant=\"contained\"\r\n                size=\"large\"\r\n                startIcon={<PlayCircleFilled />}\r\n                disabled={allPlayers.size < MIN_NUMBER_OF_PLAYERS}\r\n                onClick={() => props.sendMessage({ type: PubNubMessageType.startGame })}\r\n            >Starten</Button>\r\n        </div>\r\n    );\r\n    const createInvitePlayersElement = (): JSX.Element => (\r\n        <div className=\"material-card-style\">\r\n            <JoinGameLink gameId={gameId as string} />\r\n        </div>\r\n    );\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <div className=\"material-card-style\">\r\n                <SectionHeader showDivider={true} text=\"Gleich geht's los...\"></SectionHeader>\r\n                <div className=\"players-wrapper\">\r\n                    <h3>Mitspieler ({props.allPlayers.size}):</h3>\r\n                    <PlayerList players={props.allPlayers} />\r\n                </div>\r\n                {props.gameConfig ? createGameSettingsElement() : null}\r\n                <Divider />\r\n                {playerInfo.isAdmin ? createStartGameButton() : waitForGameStartElement}\r\n            </div>\r\n            {playerInfo.isAdmin ? createInvitePlayersElement() : null}\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\nexport default PhaseWaitingToStart;\r\n","import Pubnub from 'pubnub';\r\nimport { usePubNub } from 'pubnub-react';\r\nimport React, { useEffect } from 'react';\r\nimport { GameConfig } from '../../models/game.interface';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport { PubNubUserState } from '../../models/pub-nub-data.model';\r\n\r\ninterface PubNubEventHandlerProps {\r\n    gameChannel: string;\r\n    gameConfig: GameConfig | null;\r\n    isRejoiningGame: boolean;\r\n    playerInfo: PlayerInfo;\r\n    navigateToDashboard: () => void;\r\n    addPlayers: (...newPlayers: PubNubUserState[]) => void;\r\n    processPubNubMessage: (event: Pubnub.MessageEvent) => void;\r\n}\r\n\r\nconst PubNubEventHandler: React.FunctionComponent<PubNubEventHandlerProps> = props => {\r\n    const pubNubClient = usePubNub();\r\n\r\n    const setUserStateAndGetHereNowIfGameIsOpen = () => {\r\n        pubNubClient.history(\r\n            { channel: props.gameChannel, count: 10 },\r\n            (_, response) => {\r\n                // If a new user wants to join the game but the channel's history already includes messages, then the game\r\n                // has already started and user can't join. They get rerouted to the dashboard page by PlayGame component.\r\n                if (!props.isRejoiningGame && response.messages.length > 0) {\r\n                    props.navigateToDashboard();\r\n                    return;\r\n                }\r\n                // Only if player is joining game for the first time, set user state and retrieve hereNowData.\r\n                if (!props.isRejoiningGame) {\r\n                    setUserState();\r\n                    getHereNowData();\r\n                    // Safeguard against the possibility of two players joining exactly at the same time:\r\n                    // We call hereNowData again after 3 seconds, to make sure we get all player info.\r\n                    setTimeout(getHereNowData, 3000);\r\n                }\r\n            }\r\n        );\r\n    };\r\n    const setUserState = () => {\r\n        let newUserState: PubNubUserState;\r\n        if (props.playerInfo.isAdmin) {\r\n            newUserState = { gameConfig: props.gameConfig as GameConfig, playerInfo: props.playerInfo };\r\n        } else {\r\n            newUserState = { playerInfo: props.playerInfo };\r\n        }\r\n        // Set this user's state in game channel.\r\n        pubNubClient.setState({\r\n            channels: [props.gameChannel],\r\n            state: newUserState\r\n        });\r\n    };\r\n    const getHereNowData = () => {\r\n        pubNubClient.hereNow(\r\n            { channels: [props.gameChannel], includeUUIDs: true, includeState: true },\r\n            (_, response) => {\r\n                console.log('PubNub hereNow', response);\r\n                // If player tries to rejoin but they are the only player left in game channel, then the game \r\n                // is already over and the user gets rerouted to dashboard page by PlayGame component.\r\n                if (props.isRejoiningGame && response.totalOccupancy <= 1) {\r\n                    props.navigateToDashboard();\r\n                    return;\r\n                }\r\n                // Response includes states of players that joined before.\r\n                const dataForGameChannel = response.channels[props.gameChannel];\r\n                if (dataForGameChannel) {\r\n                    const pubNubUserStates: PubNubUserState[] = [];\r\n                    dataForGameChannel.occupants.forEach(occupant => {\r\n                        const userState = occupant.state as PubNubUserState;\r\n                        // Safeguard in case that a user's state should be missing or corrupted.\r\n                        if (!!userState && !!userState.playerInfo) {\r\n                            pubNubUserStates.push(userState);\r\n                        }\r\n                    });\r\n                    props.addPlayers(...pubNubUserStates);\r\n                }\r\n            }\r\n        );\r\n    };\r\n\r\n    useEffect(() => {\r\n        const pubNubListeners: Pubnub.ListenerParameters = {\r\n            message: messageEvent => {\r\n                console.log('PubNub message event', messageEvent);\r\n                // Make sure that message is controlled game message with 'type' attribute.\r\n                if (messageEvent.message.type) {\r\n                    props.processPubNubMessage(messageEvent);\r\n                }\r\n            },\r\n            presence: presenceEvent => {\r\n                console.log('PubNub presence event', presenceEvent);\r\n                // Check for 'state-change' events and process state from new player.\r\n                if (presenceEvent.action === 'state-change') {\r\n                    const userState = presenceEvent.state as PubNubUserState;\r\n                    if (userState.playerInfo.id !== props.playerInfo.id) {\r\n                        props.addPlayers(userState);\r\n                    }\r\n                }\r\n            },\r\n            status: statusEvent => {\r\n                console.log('PubNub status event', statusEvent);\r\n                if (statusEvent.category === 'PNConnectedCategory') {\r\n                    console.log('Player is connected to PubNub game channel');\r\n                    setUserStateAndGetHereNowIfGameIsOpen();\r\n                }\r\n            }\r\n        };\r\n        pubNubClient.addListener(pubNubListeners);\r\n        pubNubClient.subscribe({\r\n            channels: [props.gameChannel],\r\n            withPresence: true\r\n        });\r\n        // When this component is destroyed, we unsubscribe from game channel.\r\n        return () => {\r\n            pubNubClient.removeListener(pubNubListeners);\r\n            pubNubClient.unsubscribeAll();\r\n        }\r\n    });\r\n    return null;\r\n};\r\n\r\nexport default React.memo(PubNubEventHandler);\r\n","import PubNub from 'pubnub';\r\n\r\nconst PUBNUB_KEYS = require('./pubnub.config.json');\r\n\r\nexport const PUBNUB_CONFIG: PubNub.PubnubConfig = {\r\n    publishKey: PUBNUB_KEYS.publishKey,\r\n    subscribeKey: PUBNUB_KEYS.subscribeKey,\r\n    uuid: undefined, // ⇨ is set by PlayGame component,\r\n    ssl: true\r\n};\r\n","import { cloneDeep } from 'lodash';\r\nimport {\r\n    GameConfigScoringOptions,\r\n    GameRound,\r\n    GameRoundEvaluation,\r\n    PlayerInput,\r\n    PlayerInputEvaluation,\r\n} from '../models/game.interface';\r\nimport { PlayerInfo } from '../models/player.interface';\r\nimport { calculatePointsForRound, getNumberOfInvalids } from './game.utils';\r\nimport { getRunningGameRoundFromLocalStorage } from './local-storage.utils';\r\n\r\nexport const shouldUserRespondToRequestGameDataMessage = (user: PlayerInfo, allPlayers: Map<string, PlayerInfo>, requestingPlayerId: string): boolean => {\r\n    // User should not respond to their own message.\r\n    if (user.id === requestingPlayerId) { return false; }\r\n    // If user is admin, then they should respond to the message.\r\n    if (user.isAdmin) { return true; }\r\n    // If the requesting user is the admin, then an algorithm determines who of\r\n    // the remaining players is the one to respond to the admin's message.\r\n    const requestingPlayerInfo = allPlayers.get(requestingPlayerId);\r\n    if (requestingPlayerInfo && requestingPlayerInfo.isAdmin) {\r\n        const playersWithoutRequestingPlayer = cloneDeep(allPlayers);\r\n        playersWithoutRequestingPlayer.delete(requestingPlayerId);\r\n        const playersSortedById = Array.from(playersWithoutRequestingPlayer).map(data => data[1]).sort((a, b) => {\r\n            if (a.id < b.id) { return -1; }\r\n            if (a.id > b.id) { return 1; }\r\n            return 0;\r\n        });\r\n        return playersSortedById[0].id === user.id;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Transforms the GameRoundEvaluation object from a nested Map into a nested array.\r\n * The order of the players in sortedPlayers defines the order of the information in the arrays.\r\n */\r\nexport const compressGameRoundEvaluation = (gameRoundEvaluation: GameRoundEvaluation, sortedPlayers: PlayerInfo[]): boolean[][][] => {\r\n    const evaluationsAsArrays = new Map<string, boolean[][]>();\r\n    gameRoundEvaluation.forEach((data, playerId) => {\r\n        evaluationsAsArrays.set(playerId, data.map(item => {\r\n            const booleanArray: boolean[] = [];\r\n            sortedPlayers.forEach(player => booleanArray.push(item.get(player.id) as boolean));\r\n            return booleanArray;\r\n        }));\r\n    });\r\n    const compressedGameRoundEvaluation: boolean[][][] = [];\r\n    sortedPlayers.forEach(player => compressedGameRoundEvaluation.push(evaluationsAsArrays.get(player.id) as boolean[][]));\r\n    return compressedGameRoundEvaluation;\r\n};\r\n\r\n/**\r\n * Transforms the GameRoundEvaluation object from a nested array into a nested Map.\r\n * The order of the players in sortedPlayers defines the order of the information in the arrays.\r\n */\r\nexport const decompressGameRoundEvaluation = (compressedData: boolean[][][], sortedPlayers: PlayerInfo[]): GameRoundEvaluation => {\r\n    const gameRoundEvaluation: GameRoundEvaluation = new Map<string, PlayerInputEvaluation[]>();\r\n    sortedPlayers.forEach((evaluatedPlayer, evaluatedPlayerIndex) => {\r\n        const evaluations: PlayerInputEvaluation[] = compressedData[evaluatedPlayerIndex].map(playerData => {\r\n            const playerInputEvaluation = new Map<string, boolean>();\r\n            sortedPlayers.forEach((evaluatingPlayer, evaluatingPlayerIndex) => playerInputEvaluation.set(evaluatingPlayer.id, playerData[evaluatingPlayerIndex]));\r\n            return playerInputEvaluation;\r\n        });\r\n        gameRoundEvaluation.set(evaluatedPlayer.id, evaluations);\r\n    });\r\n    return gameRoundEvaluation;\r\n};\r\n\r\n/**\r\n * Transforms the GameRoundEvaluation object from a nested Map into a nested array.\r\n * The order of the players in sortedPlayers defines the order of the information in the arrays.\r\n */\r\nexport const compressMarkedAsCreativeFlags = (round: GameRound, sortedPlayers: PlayerInfo[]): boolean[][] => {\r\n    const markedAsCreativeArrays: boolean[][] = [];\r\n    sortedPlayers.forEach(player => {\r\n        const playerInputs = round.get(player.id) as PlayerInput[];\r\n        markedAsCreativeArrays.push(playerInputs.map(input => input.star));\r\n    });\r\n    return markedAsCreativeArrays;\r\n};\r\n\r\nexport const restoreGameRoundsOfRunningGameFromLocalStorage = (numberOfRoundsToRestore: number): GameRound[] => {\r\n    const gameRounds: GameRound[] = [];\r\n    for (let round = 1; round <= numberOfRoundsToRestore; round++) {\r\n        const data = getRunningGameRoundFromLocalStorage(round);\r\n        if (data) {\r\n            gameRounds.push(data);\r\n        }\r\n    }\r\n    return gameRounds;\r\n};\r\n\r\n/**\r\n * Sets points and validity of player inputs for a player who is rejoining the game in evaluation phase.\r\n */\r\nexport const setPointsAndValidity = (\r\n    scoringOptions: GameConfigScoringOptions, gameRoundEvaluation: GameRoundEvaluation, minNumberOfInvalids: number, round: GameRound\r\n) => {\r\n    // First evaluate validity\r\n    round.forEach((playerInputs, playerId) => {\r\n        const evaluations = gameRoundEvaluation.get(playerId) as PlayerInputEvaluation[];\r\n        playerInputs.forEach((input, categoryIndex) => {\r\n            // Only evaluate validity for originally valid inputs (not empty text inputs).\r\n            if (input.valid) {\r\n                input.valid = getNumberOfInvalids(evaluations[categoryIndex]) < minNumberOfInvalids;\r\n            }\r\n        });\r\n    });\r\n    // Second calculate points\r\n    calculatePointsForRound(scoringOptions, round);\r\n};\r\n\r\n/**\r\n * Applies the \"marked as very creative\" flags to the player inputs for a player who is rejoining the game in evaluation phase.\r\n */\r\nexport const applyMarkedAsCreativeFlags = (compressedData: boolean[][], sortedPlayers: PlayerInfo[], round: GameRound) => {\r\n    sortedPlayers.forEach((player, playerIndex) => {\r\n        const markedAsCreativeAnswer = compressedData[playerIndex];\r\n        (round.get(player.id) as PlayerInput[]).forEach((input, categoryIndex) => input.star = markedAsCreativeAnswer[categoryIndex]);\r\n    });\r\n};\r\n","import { cloneDeep } from 'lodash';\r\nimport Pubnub from 'pubnub';\r\nimport { PubNubProvider } from 'pubnub-react';\r\nimport React, { Component, Dispatch } from 'react';\r\nimport { connect } from 'react-redux';\r\nimport { RouterProps } from 'react-router';\r\nimport AdminPanel from '../../components/AdminPanel/AdminPanel';\r\nimport { LetterAnimation } from '../../components/LetterAnimation/LetterAnimation';\r\nimport LoadingScreen from '../../components/LoadingScreen/LoadingScreen';\r\nimport PhaseEvaluateRound from '../../components/PhaseEvaluateRound/PhaseEvaluateRound';\r\nimport PhaseFillOutTextfields from '../../components/PhaseFillOutTextfields/PhaseFillOutTextfields';\r\nimport PhaseWaitingToStart from '../../components/PhaseWaitingToStart/PhaseWaitingToStart';\r\nimport PubNubEventHandler from '../../components/PubNubEventHandler/PubNubEventHandler';\r\nimport { PUBNUB_CONFIG } from '../../config/pubnub.config';\r\nimport { GamePhase } from '../../constants/game.constant';\r\nimport {\r\n    EvaluationOfPlayerInput,\r\n    GameConfig,\r\n    GameRound,\r\n    GameRoundEvaluation,\r\n    IsPlayerInputVeryCreativeStatus,\r\n    PlayerInput,\r\n    PlayerInputEvaluation,\r\n} from '../../models/game.interface';\r\nimport { PlayerInfo } from '../../models/player.interface';\r\nimport {\r\n    PubNubCurrentRoundInputsMessage,\r\n    PubNubDataForCurrentGameMessage,\r\n    PubNubDataForCurrentGameMessagePayload,\r\n    PubNubEvaluationOfPlayerInputMessage,\r\n    PubNubIsPlayerInputVeryCreativeMessage,\r\n    PubNubKickPlayerMessage,\r\n    PubNubMessage,\r\n    PubNubMessageType,\r\n    PubNubUserState,\r\n} from '../../models/pub-nub-data.model';\r\nimport { AppAction, resetAppState, setDataOfFinishedGame, SetDataOfFinishedGamePayload } from '../../store/app.actions';\r\nimport { AppState } from '../../store/app.reducer';\r\nimport {\r\n    applyMarkedAsCreativeFlags,\r\n    compressGameRoundEvaluation,\r\n    compressMarkedAsCreativeFlags,\r\n    decompressGameRoundEvaluation,\r\n    restoreGameRoundsOfRunningGameFromLocalStorage,\r\n    setPointsAndValidity,\r\n    shouldUserRespondToRequestGameDataMessage,\r\n} from '../../utils/data-restoration.utils';\r\nimport {\r\n    applyValidFlagAndStarFlagToPoints,\r\n    calculatePointsForCategory,\r\n    calculatePointsForRound,\r\n    createGameRoundEvaluation,\r\n    getEmptyRoundInputs,\r\n    getMinNumberOfInvalids,\r\n    getNumberOfInvalids,\r\n    getPlayersInAlphabeticalOrder,\r\n    markEmptyPlayerInputsAsInvalid,\r\n} from '../../utils/game.utils';\r\nimport { convertCollectionToMap, convertMapToCollection } from '../../utils/general.utils';\r\nimport {\r\n    getRunningGameConfigFromLocalStorage,\r\n    removeAllDataOfRunningGameFromLocalStorage,\r\n    setRunningGameConfigInLocalStorage,\r\n    setRunningGameRoundInLocalStorage,\r\n} from '../../utils/local-storage.utils';\r\n\r\ninterface PlayGamePropsFromStore {\r\n    gameConfig: GameConfig | null;\r\n    gameId: string | null;\r\n    isRejoiningGame: boolean;\r\n    /** Player info for the user of this instance of the \"Stadt-Land-Fluss\" app. */\r\n    playerInfo: PlayerInfo;\r\n}\r\ninterface PlayGameDispatchProps {\r\n    onSetDataOfFinishedGame: (payload: SetDataOfFinishedGamePayload) => void;\r\n    onResetAppState: () => void;\r\n}\r\ninterface PlayGameProps extends PlayGamePropsFromStore, PlayGameDispatchProps, RouterProps { }\r\nexport interface PlayGameState {\r\n    allPlayers: Map<string, PlayerInfo>;\r\n    currentPhase: GamePhase;\r\n    currentRound: number;\r\n    currentRoundEvaluation: GameRoundEvaluation;\r\n    currentRoundInputs: PlayerInput[];\r\n    gameConfig: GameConfig | null;\r\n    gameRounds: GameRound[];\r\n    playersThatFinishedEvaluation: Map<string, boolean>;\r\n    showLetterAnimation: boolean;\r\n    showLoadingScreen: boolean;\r\n}\r\n\r\nclass PlayGame extends Component<PlayGameProps, PlayGameState> {\r\n    public state: PlayGameState = {\r\n        allPlayers: new Map<string, PlayerInfo>(),\r\n        currentPhase: GamePhase.waitingToStart,\r\n        currentRound: 1,\r\n        currentRoundEvaluation: new Map<string, PlayerInputEvaluation[]>(),\r\n        currentRoundInputs: [],\r\n        gameConfig: null,\r\n        gameRounds: [],\r\n        playersThatFinishedEvaluation: new Map<string, boolean>(),\r\n        showLetterAnimation: false,\r\n        showLoadingScreen: true\r\n    };\r\n    private pubNubClient: any;\r\n\r\n    public render() {\r\n        // This check serves as a route guard. If gameId and playerInfo aren't present in application state,\r\n        // then the user wasn't redirected here from the NewGame or JoinGame component.\r\n        if (this.props.gameId === null || this.props.playerInfo === null) { return null; }\r\n\r\n        if (!this.pubNubClient) {\r\n            this.pubNubClient = new Pubnub({ ...PUBNUB_CONFIG, uuid: this.props.playerInfo.id });\r\n        }\r\n        const letterAnimationElement = (\r\n            <LetterAnimation\r\n                letterToUnveil={this.state.gameConfig ? this.state.gameConfig.letters[this.state.currentRound - 1] : ''}\r\n                callbackWhenAnimationDone={this.callbackWhenAnimationDone}\r\n            />\r\n        );\r\n        const adminPanel = <AdminPanel allPlayers={this.state.allPlayers} kickPlayer={this.sendKickPlayerMessage} />;\r\n        const { showLetterAnimation, showLoadingScreen } = this.state;\r\n\r\n        return (\r\n            <PubNubProvider client={this.pubNubClient}>\r\n                {/* The props passed to PubNubEventHandler must never be changed,\r\n                    in order to ensure that the component is not rerendered!\r\n                    (PubNubEventHandler is wrapped in React.memo) */}\r\n                <PubNubEventHandler\r\n                    gameChannel={this.props.gameId}\r\n                    gameConfig={this.props.gameConfig}\r\n                    isRejoiningGame={this.props.isRejoiningGame}\r\n                    playerInfo={this.props.playerInfo}\r\n                    navigateToDashboard={this.navigateToDashboard}\r\n                    addPlayers={this.addPlayers}\r\n                    processPubNubMessage={this.processPubNubMessage}\r\n                />\r\n                {showLetterAnimation ? letterAnimationElement : null}\r\n                {showLoadingScreen ? <LoadingScreen /> : null}\r\n                {!showLoadingScreen && !showLetterAnimation ? (\r\n                    <div className=\"main-content-wrapper\">\r\n                        {this.createCurrentPhaseElement()}\r\n                    </div>\r\n                ) : null}\r\n                {this.props.playerInfo.isAdmin && this.state.allPlayers.size > 1 ? adminPanel : null}\r\n            </PubNubProvider>\r\n        );\r\n    }\r\n\r\n    public componentDidMount() {\r\n        const { gameConfig, gameId, isRejoiningGame, playerInfo } = this.props;\r\n        // If gameId and playerInfo aren't present in application state, then reroute user to dashboard.\r\n        if (gameId === null || playerInfo === null) {\r\n            this.props.history.push('/');\r\n            return;\r\n        }\r\n        // If player is rejoining the game, we need to request the game data from the other players.\r\n        if (isRejoiningGame) {\r\n            this.sendMessage({ type: PubNubMessageType.requestGameData });\r\n        } else {\r\n            const allPlayers = new Map<string, PlayerInfo>();\r\n            allPlayers.set(playerInfo.id, playerInfo);\r\n            // If user is the game admin, the gameConfig can be taken from application state\r\n            // and we can hide the loading screen and show PhaseWaitingToStart component right away.\r\n            if (playerInfo.isAdmin) {\r\n                setRunningGameConfigInLocalStorage(gameConfig as GameConfig);\r\n                this.setState({ allPlayers, gameConfig, showLoadingScreen: false });\r\n            } else {\r\n                this.setState({ allPlayers });\r\n            }\r\n        }\r\n    }\r\n\r\n    private sendMessage = (message: PubNubMessage) => {\r\n        this.pubNubClient.publish(\r\n            {\r\n                channel: this.props.gameId as string,\r\n                message,\r\n                storeInHistory: true,\r\n                ttl: 1 // time to live (in hours)\r\n            },\r\n            (status: any, response: any) => console.log('PubNub Publish:', status, response)\r\n        );\r\n    };\r\n\r\n    private createCurrentPhaseElement = (): JSX.Element | null => {\r\n        switch (this.state.currentPhase) {\r\n            case GamePhase.waitingToStart:\r\n                return (\r\n                    <PhaseWaitingToStart\r\n                        allPlayers={this.state.allPlayers}\r\n                        gameConfig={this.state.gameConfig}\r\n                        gameId={this.props.gameId as string}\r\n                        playerInfo={this.props.playerInfo}\r\n                        sendMessage={this.sendMessage}\r\n                    />\r\n                );\r\n            case GamePhase.fillOutTextfields:\r\n                return (\r\n                    <PhaseFillOutTextfields\r\n                        currentRound={this.state.currentRound}\r\n                        gameConfig={this.state.gameConfig as GameConfig}\r\n                        gameRoundInputs={this.state.currentRoundInputs}\r\n                        updateCurrentRoundInputs={this.updateCurrentRoundInputs}\r\n                        finishRoundOnCountdownComplete={this.finishRoundOnCountdownComplete}\r\n                        finishRoundOnUserAction={this.finishRoundOnUserAction}\r\n                    />\r\n                );\r\n            case GamePhase.evaluateRound:\r\n                return (\r\n                    <PhaseEvaluateRound\r\n                        allPlayers={this.state.allPlayers}\r\n                        currentRound={this.state.currentRound}\r\n                        currentRoundEvaluation={this.state.currentRoundEvaluation}\r\n                        gameConfig={this.state.gameConfig as GameConfig}\r\n                        gameRounds={this.state.gameRounds}\r\n                        playerInfo={this.props.playerInfo}\r\n                        playersThatFinishedEvaluation={this.state.playersThatFinishedEvaluation}\r\n                        sendEvaluationFinishedMessage={this.sendEvaluationFinishedMessage}\r\n                        updateEvaluationOfPlayerInput={this.updateEvaluationOfPlayerInput}\r\n                        updateIsPlayerInputVeryCreativeStatus={this.updateIsPlayerInputVeryCreativeStatus}\r\n                    />\r\n                );\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    private callbackWhenAnimationDone = () => {\r\n        this.setState({ showLetterAnimation: false });\r\n    }\r\n\r\n    private navigateToDashboard = () => {\r\n        removeAllDataOfRunningGameFromLocalStorage();\r\n        this.props.onResetAppState();\r\n        this.props.history.push('/');\r\n    }\r\n\r\n    /**\r\n     * Called by PubNubEventHandler when it receives a PubNub presence event with action 'state-change'.\r\n     * It processes information about players that had already joined the game before this user joined\r\n     * (hereNow result) or about a player that joins the game after this user joined.\r\n     */\r\n    private addPlayers = (...newPlayers: PubNubUserState[]) => {\r\n        // Ignore information about players that try to join after the game has already started.\r\n        if (this.state.currentPhase !== GamePhase.waitingToStart) { return; }\r\n        let gameConfig: GameConfig | null = null;\r\n        const allPlayers = cloneDeep(this.state.allPlayers);\r\n        newPlayers.forEach(newPlayer => {\r\n            allPlayers.set(newPlayer.playerInfo.id, newPlayer.playerInfo);\r\n            // If we are not the game admin, we obtain the game config from the admin's PubNubUserState.\r\n            if (newPlayer.gameConfig && !this.state.gameConfig) {\r\n                gameConfig = newPlayer.gameConfig;\r\n            }\r\n        });\r\n        // Only after we received the gameConfig from the admin, we hide the loading screen\r\n        // and render the PhaseWaitingToStart component instead.\r\n        if (gameConfig) {\r\n            setRunningGameConfigInLocalStorage(gameConfig);\r\n            this.setState({ allPlayers, gameConfig, showLoadingScreen: false });\r\n        } else {\r\n            this.setState({ allPlayers });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * PubNubEventHandler calls this method when it receives a PubNub message with attribute 'type'.\r\n     */\r\n    private processPubNubMessage = (event: Pubnub.MessageEvent) => {\r\n        const message = event.message as PubNubMessage;\r\n        switch (message.type) {\r\n            case PubNubMessageType.startGame:\r\n                this.startGame();\r\n                break;\r\n            case PubNubMessageType.roundFinished:\r\n                this.stopRoundAndSendInputs();\r\n                break;\r\n            case PubNubMessageType.currentRoundInputs:\r\n                this.addPlayerInputForFinishedRound(event.publisher, message.payload);\r\n                break;\r\n            case PubNubMessageType.evaluationOfPlayerInput:\r\n                this.processEvaluationOfPlayerInput(event.publisher, message.payload);\r\n                break;\r\n            case PubNubMessageType.isPlayerInputVeryCreative:\r\n                this.processIsPlayerInputVeryCreativeStatus(message.payload);\r\n                break;\r\n            case PubNubMessageType.evaluationFinished:\r\n                this.countPlayerAsEvaluationFinished(event.publisher);\r\n                break;\r\n            case PubNubMessageType.kickPlayer:\r\n                this.removePlayerFromGame(message.payload)\r\n                break;\r\n            case PubNubMessageType.requestGameData:\r\n                if (shouldUserRespondToRequestGameDataMessage(this.props.playerInfo, this.state.allPlayers, event.publisher)) {\r\n                    if (this.state.allPlayers.has(event.publisher)) {\r\n                        // Only send data to a rejoining player who hasn't been kicked out by the admin.\r\n                        this.sendDataForCurrentGame(event.publisher);\r\n                    } else {\r\n                        // Send kickPlayer message again for kicked out player that tried to rejoin game.\r\n                        this.sendKickPlayerMessage(event.publisher);\r\n                    }\r\n                }\r\n                break;\r\n            case PubNubMessageType.dataForCurrentGame:\r\n                this.restoreDataForCurrentGame(message.payload);\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n\r\n    /**\r\n    * This method is called when the PubNub message 'startGame' is received.\r\n    */\r\n    private startGame = () => {\r\n        const gameConfig = this.state.gameConfig as GameConfig;\r\n        const currentRoundEvaluation = createGameRoundEvaluation(this.state.allPlayers, gameConfig.categories);\r\n        this.setState({\r\n            currentPhase: GamePhase.fillOutTextfields,\r\n            currentRoundEvaluation,\r\n            currentRoundInputs: getEmptyRoundInputs(gameConfig.categories.length),\r\n            showLetterAnimation: true\r\n        });\r\n    }\r\n\r\n    private updateCurrentRoundInputs = (newCurrentRoundInputs: PlayerInput[]) => {\r\n        this.setState({ currentRoundInputs: newCurrentRoundInputs });\r\n    }\r\n\r\n    /**\r\n     * Gets called when the countdown reaches zero (isUserAction = false).\r\n     */\r\n    private finishRoundOnCountdownComplete = () => {\r\n        this.setState({ showLoadingScreen: true });\r\n        // We only want the game admin to send the \"roundFinished\" message once.\r\n        if (this.props.playerInfo.isAdmin) {\r\n            this.sendMessage({ type: PubNubMessageType.roundFinished });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets called when the user ends the current round.\r\n     */\r\n    private finishRoundOnUserAction = () => {\r\n        this.setState({ showLoadingScreen: true });\r\n        this.sendMessage({ type: PubNubMessageType.roundFinished });\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'roundFinished' is received.\r\n     */\r\n    private stopRoundAndSendInputs = () => {\r\n        // Prepare new GameRound object for addPlayerInputForFinishedRound method\r\n        // as well as new currentRoundEvaluation object for evaluation phase.\r\n        const gameRounds: GameRound[] = [...this.state.gameRounds, new Map<string, PlayerInput[]>()];\r\n        this.setState({ gameRounds, showLoadingScreen: true });\r\n        // Send this player's text inputs of current round to other players (and herself/himself).\r\n        const message = new PubNubCurrentRoundInputsMessage(markEmptyPlayerInputsAsInvalid(this.state.currentRoundInputs));\r\n        this.sendMessage(message.toPubNubMessage());\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'currentRoundInputs' is received.\r\n     */\r\n    private addPlayerInputForFinishedRound = (playerId: string, playerInputsForFinishedRound: PlayerInput[]) => {\r\n        const gameRounds = cloneDeep(this.state.gameRounds);\r\n        const roundIndex = this.state.currentRound - 1;\r\n        gameRounds[roundIndex].set(playerId, playerInputsForFinishedRound);\r\n        // Did we collect the inputs from all players?\r\n        if (gameRounds[roundIndex].size === this.state.allPlayers.size) {\r\n            // If yes, then calculate points and start the evaluation of the finished round.\r\n            calculatePointsForRound((this.state.gameConfig as GameConfig).scoringOptions, gameRounds[roundIndex]);\r\n            setRunningGameRoundInLocalStorage(this.state.currentRound, gameRounds[roundIndex]);\r\n            this.setState({ currentPhase: GamePhase.evaluateRound, gameRounds, showLoadingScreen: false });\r\n        } else {\r\n            // If no, then only store the updated gameRounds object in state.\r\n            this.setState({ gameRounds });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is called by PhaseEvaluateRound component in order to communicate a player input evaluation via a\r\n     * PubNub message. This message is then processed by all players in the game (including the user who sent it).\r\n     */\r\n    private updateEvaluationOfPlayerInput = (newEvaluation: EvaluationOfPlayerInput) => {\r\n        const message = new PubNubEvaluationOfPlayerInputMessage(newEvaluation);\r\n        this.sendMessage(message.toPubNubMessage());\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'evaluationOfPlayerInput' is received.\r\n     * It processes the new evaluation and changes data in currentRoundEvaluation and gameRounds accordingly.\r\n     */\r\n    private processEvaluationOfPlayerInput = (evaluatingPlayerId: string, newEvaluation: EvaluationOfPlayerInput) => {\r\n        if (!this.state.allPlayers.has(evaluatingPlayerId)) { return; }\r\n        const { categoryIndex, evaluatedPlayerId, markedAsValid } = newEvaluation;\r\n        const currentRoundEvaluation = cloneDeep(this.state.currentRoundEvaluation);\r\n        const playerInputEvaluations = currentRoundEvaluation.get(evaluatedPlayerId) as PlayerInputEvaluation[];\r\n        playerInputEvaluations[categoryIndex].set(evaluatingPlayerId, markedAsValid);\r\n        const gameRounds = cloneDeep(this.state.gameRounds);\r\n        const isInputValid = getNumberOfInvalids(playerInputEvaluations[categoryIndex]) < getMinNumberOfInvalids(this.state.allPlayers.size);\r\n        const finishedRound = gameRounds[this.state.currentRound - 1];\r\n        (finishedRound.get(evaluatedPlayerId) as PlayerInput[])[categoryIndex].valid = isInputValid;\r\n        calculatePointsForCategory((this.state.gameConfig as GameConfig).scoringOptions, finishedRound, categoryIndex);\r\n        this.setState({ currentRoundEvaluation, gameRounds });\r\n    }\r\n\r\n    /**\r\n     * Is called by PhaseEvaluateRound component in order to communicate the \"marked as very creative\" status of a player input\r\n     * via a PubNub message. This message is then processed by all players in the game (including the user who sent it).\r\n     */\r\n    private updateIsPlayerInputVeryCreativeStatus = (newStatus: IsPlayerInputVeryCreativeStatus) => {\r\n        const message = new PubNubIsPlayerInputVeryCreativeMessage(newStatus);\r\n        this.sendMessage(message.toPubNubMessage());\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'isPlayerInputVeryCreative' is received.\r\n     * It processes the new status and changes data in gameRounds accordingly.\r\n     */\r\n    private processIsPlayerInputVeryCreativeStatus = (newStatus: IsPlayerInputVeryCreativeStatus) => {\r\n        const { categoryIndex, evaluatedPlayerId, markedAsCreative } = newStatus;\r\n        const gameRounds = cloneDeep(this.state.gameRounds);\r\n        const finishedRound = gameRounds[this.state.currentRound - 1];\r\n        (finishedRound.get(evaluatedPlayerId) as PlayerInput[])[categoryIndex].star = markedAsCreative;\r\n        this.setState({ gameRounds });\r\n    }\r\n\r\n    /**\r\n     * Is called by PhaseEvaluateRound component in order to communicate to all players\r\n     * that the user of this instance of the game has finished evaluating the current round.\r\n     */\r\n    private sendEvaluationFinishedMessage = () => this.sendMessage({ type: PubNubMessageType.evaluationFinished });\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'evaluationFinished' is received.\r\n     */\r\n    private countPlayerAsEvaluationFinished = (evaluatingPlayerId: string) => {\r\n        const playersThatFinishedEvaluation = cloneDeep(this.state.playersThatFinishedEvaluation);\r\n        playersThatFinishedEvaluation.set(evaluatingPlayerId, true);\r\n        if (playersThatFinishedEvaluation.size === this.state.allPlayers.size) {\r\n            this.processEvaluationsAndStartNextRoundOrFinishGame();\r\n        } else {\r\n            this.setState({ playersThatFinishedEvaluation });\r\n        }\r\n    }\r\n\r\n    private processEvaluationsAndStartNextRoundOrFinishGame = () => {\r\n        const { allPlayers, currentRound } = this.state;\r\n        const gameConfig = this.state.gameConfig as GameConfig;\r\n        const gameRounds = cloneDeep(this.state.gameRounds);\r\n        applyValidFlagAndStarFlagToPoints(gameConfig.scoringOptions, gameRounds[currentRound - 1]);\r\n        if (currentRound === gameConfig.numberOfRounds) {\r\n            // Finish game and show results.\r\n            removeAllDataOfRunningGameFromLocalStorage();\r\n            this.props.onSetDataOfFinishedGame({ allPlayers, gameConfig, gameRounds });\r\n            this.props.history.push('/results');\r\n        } else {\r\n            // Save finished game round in local storage and start next round of the game.\r\n            setRunningGameRoundInLocalStorage(this.state.currentRound, gameRounds[currentRound - 1]);\r\n            this.setState({\r\n                currentPhase: GamePhase.fillOutTextfields,\r\n                currentRoundEvaluation: createGameRoundEvaluation(allPlayers, gameConfig.categories),\r\n                currentRoundInputs: getEmptyRoundInputs(gameConfig.categories.length),\r\n                currentRound: currentRound + 1,\r\n                gameRounds,\r\n                playersThatFinishedEvaluation: new Map<string, boolean>(),\r\n                showLetterAnimation: true\r\n            });\r\n        }\r\n    }\r\n\r\n    private sendKickPlayerMessage = (playerId: string) => {\r\n        const message = new PubNubKickPlayerMessage(playerId);\r\n        this.sendMessage(message.toPubNubMessage());\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'kickPlayer' is received.\r\n     */\r\n    private removePlayerFromGame = (playerId: string) => {\r\n        // If the player to be removed is the user of this game instance, then navigate to dashboard.\r\n        if (this.props.playerInfo.id === playerId) {\r\n            removeAllDataOfRunningGameFromLocalStorage();\r\n            this.props.onResetAppState();\r\n            this.props.history.push('/');\r\n            return;\r\n        }\r\n        if (this.state.allPlayers.has(playerId)) {\r\n            // Remove player's data from component's state.\r\n            const allPlayers = cloneDeep(this.state.allPlayers);\r\n            allPlayers.delete(playerId);\r\n            const currentRoundEvaluation = cloneDeep(this.state.currentRoundEvaluation);\r\n            currentRoundEvaluation.delete(playerId);\r\n            const gameRounds = cloneDeep(this.state.gameRounds);\r\n            gameRounds.forEach(round => round.delete(playerId));\r\n            const playersThatFinishedEvaluation = cloneDeep(this.state.playersThatFinishedEvaluation);\r\n            playersThatFinishedEvaluation.delete(playerId);\r\n            this.setState({ allPlayers, currentRoundEvaluation, gameRounds, playersThatFinishedEvaluation });\r\n            // If we're currently in evaluation phase, check if remaining players have finished evaluation.\r\n            if (this.state.currentPhase === GamePhase.evaluateRound && playersThatFinishedEvaluation.size === allPlayers.size) {\r\n                this.processEvaluationsAndStartNextRoundOrFinishGame();\r\n            }\r\n        }\r\n    }\r\n\r\n    private sendDataForCurrentGame = (requestingPlayerId: string) => {\r\n        const { allPlayers, currentPhase, currentRound, currentRoundEvaluation, gameRounds } = this.state;\r\n        const sortedPlayers = getPlayersInAlphabeticalOrder(allPlayers);\r\n        const compressedGameRoundEvaluation = currentPhase === GamePhase.evaluateRound\r\n            ? compressGameRoundEvaluation(currentRoundEvaluation, sortedPlayers) : [];\r\n        const compressedMarkedAsCreativeFlags = currentPhase === GamePhase.evaluateRound\r\n            ? compressMarkedAsCreativeFlags(gameRounds[currentRound - 1], sortedPlayers) : [];\r\n        const message = new PubNubDataForCurrentGameMessage({\r\n            compressedGameRoundEvaluation,\r\n            compressedMarkedAsCreativeFlags,\r\n            currentPhase,\r\n            currentRound,\r\n            playersThatFinishedEvaluation: convertMapToCollection<boolean>(this.state.playersThatFinishedEvaluation),\r\n            requestingPlayerId,\r\n            sortedPlayers\r\n        });\r\n        this.sendMessage(message.toPubNubMessage());\r\n    }\r\n\r\n    /**\r\n     * This method is called when the PubNub message 'dataForCurrentGame' is received.\r\n     */\r\n    private restoreDataForCurrentGame = (payload: PubNubDataForCurrentGameMessagePayload) => {\r\n        // Only process the information and update state if the message was meant for this user.\r\n        if (this.props.playerInfo.id !== payload.requestingPlayerId) { return; }\r\n\r\n        const gameConfig = getRunningGameConfigFromLocalStorage();\r\n        // If we're in the evaluation phase, then we also need to restore the data for the current round.\r\n        // Otherwise we only need to restore the data of the finished rounds.\r\n        const numberOfRoundsToRestore = payload.currentPhase === GamePhase.evaluateRound ? payload.currentRound : payload.currentRound - 1;\r\n        const gameRounds = restoreGameRoundsOfRunningGameFromLocalStorage(numberOfRoundsToRestore);\r\n        if (gameConfig && gameRounds.length === numberOfRoundsToRestore) {\r\n            const allPlayers = new Map<string, PlayerInfo>();\r\n            payload.sortedPlayers.forEach(player => allPlayers.set(player.id, player));\r\n            let currentRoundEvaluation: GameRoundEvaluation;\r\n            // If we are in evaluation phase, then we received the current evaluations and the\r\n            // \"marked as very creative\" data, which we need to apply to the player inputs.\r\n            if (payload.currentPhase === GamePhase.evaluateRound) {\r\n                const round = gameRounds[payload.currentRound - 1];\r\n                currentRoundEvaluation = decompressGameRoundEvaluation(payload.compressedGameRoundEvaluation, payload.sortedPlayers);\r\n                setPointsAndValidity(gameConfig.scoringOptions, currentRoundEvaluation, getMinNumberOfInvalids(allPlayers.size), round);\r\n                applyMarkedAsCreativeFlags(payload.compressedMarkedAsCreativeFlags, payload.sortedPlayers, round);\r\n            } else {\r\n                currentRoundEvaluation = createGameRoundEvaluation(allPlayers, gameConfig.categories);\r\n            }\r\n            this.setState({\r\n                allPlayers,\r\n                currentPhase: payload.currentPhase,\r\n                currentRound: payload.currentRound,\r\n                currentRoundEvaluation,\r\n                currentRoundInputs: getEmptyRoundInputs(gameConfig.categories.length),\r\n                gameConfig,\r\n                gameRounds,\r\n                playersThatFinishedEvaluation: convertCollectionToMap<boolean>(payload.playersThatFinishedEvaluation),\r\n                showLoadingScreen: false\r\n            });\r\n        } else {\r\n            console.log('Error: Can\\'t restore game session because data is missing in local storage!');\r\n            this.navigateToDashboard();\r\n        }\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state: AppState): PlayGamePropsFromStore => {\r\n    return {\r\n        gameConfig: state.gameConfig,\r\n        gameId: state.gameId,\r\n        isRejoiningGame: state.isRejoiningGame,\r\n        playerInfo: state.playerInfo as PlayerInfo\r\n    };\r\n}\r\nconst mapDispatchToProps = (dispatch: Dispatch<AppAction>): PlayGameDispatchProps => {\r\n    return {\r\n        onSetDataOfFinishedGame: (payload: SetDataOfFinishedGamePayload) => dispatch(setDataOfFinishedGame(payload)),\r\n        onResetAppState: () => dispatch(resetAppState())\r\n    }\r\n};\r\nexport default connect(mapStateToProps, mapDispatchToProps)(PlayGame);\r\n"],"sourceRoot":""}